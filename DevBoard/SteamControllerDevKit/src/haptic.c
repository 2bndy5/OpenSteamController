/**
 * \file haptic.c
 * \brief Encompasses functions for interfacing with haptics.
 *
 * MIT License
 *
 * Copyright (c) 2017 Gregory Gluszek
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include "haptic.h"

#include <stdlib.h>
#include <string.h>

#include "console.h"

#include "lpc_types.h"
#include "chip.h"
#include "timer_11xx.h"

#define GPIO_HAPTICS_EN_N 1, 7
#define GPIO_HAPTICS_L 0, 18
#define GPIO_HAPTICS_R 1, 12

/**
 * \return the Match Register number for the corresponding haptic.
 */
inline static int8_t getHapticMR(Haptic haptic) {
	return (int8_t)haptic + 1;
}

/**
 * Change state of GPIO that controls haptic.
 */
inline static void setHapticGpioState(Haptic haptic, bool setting) {
	if (haptic == R_HAPTIC) {
		Chip_GPIO_WritePortBit(LPC_GPIO, GPIO_HAPTICS_R, setting);
	}
	if (haptic == L_HAPTIC) {
		Chip_GPIO_WritePortBit(LPC_GPIO, GPIO_HAPTICS_L, setting);
	}
}

/**
 * \return Get state of GPIO that controls haptic.
 */
inline static bool getHapticGpioState(Haptic haptic) {
	if (haptic == R_HAPTIC) {
		return Chip_GPIO_ReadPortBit(LPC_GPIO, GPIO_HAPTICS_R);
	}
	if (haptic == L_HAPTIC) {
		return Chip_GPIO_ReadPortBit(LPC_GPIO, GPIO_HAPTICS_L);
	}

	return false;
}

static LPC_TIMER_T* hapticTimer = LPC_TIMER32_0;

//TODO: add default jingle data here

static volatile bool hapticBusy[2]; //!< non-zero if the haptic is currently 
	//!< playing a sequence.
static volatile const Note* hapticNotes[2]; //!< Pointer to the first note in a 
 	//!< sequence to play on the haptics.
static volatile uint16_t hapticRepeatCnt[2]; //!< Counter for repeating current
	//!< Note.
static volatile int hapticNotesIdx[2]; //!< Index of which note is currently
	//!< being played on a haptic.
static volatile int hapticNotesLen[2]; //!< The number of notes in a sequence 
	//!< to be played on a haptic.

/**
 * Change state of haptic based on currently setup sequence.
 * 
 * \param haptic Defines which haptic we are referring too. 
 *
 * \return None.
 */
static void nextHapticState(Haptic haptic) {
	volatile const Note* notes = hapticNotes[haptic];

	if (getHapticGpioState(haptic)) {
		// High portion of pulse is finished, on to low portion
		setHapticGpioState(haptic, false);
		// Setup interrupt to occur when low portion is done
		hapticTimer->MR[getHapticMR(haptic)] = 
			notes[hapticNotesIdx[haptic]].lowDuration + 
			Chip_TIMER_ReadCount(hapticTimer);
	} else {
		// Pulse low finished (i.e. iteration of note is complete)
		hapticRepeatCnt[haptic]++;

		// Check if note is to be repeated
		if (hapticRepeatCnt[haptic] >= 
			notes[hapticNotesIdx[haptic]].repeatCnt) {

			// Attempt to move onto next note in sequence
			hapticNotesIdx[haptic]++;
			hapticRepeatCnt[haptic] = 0;
			if (hapticNotesIdx[haptic] >= hapticNotesLen[haptic]) {
				// Stop interrupt from firing as all notes in 
				//  sequence have been played
				hapticBusy[haptic] = false;			
//TODO: need to protect this with lock mechanism?
				Chip_TIMER_MatchDisableInt(hapticTimer, 
					getHapticMR(haptic));
				
				return;
			}
		}

		// Drive haptic high for desired time
		setHapticGpioState(haptic, true);
		// Setup interrupt to occur when high portion is done
		hapticTimer->MR[getHapticMR(haptic)] = 
			notes[hapticNotesIdx[haptic]].highDuration + 
			Chip_TIMER_ReadCount(hapticTimer);

	}
}

volatile bool itHappened = false;

/**
 * Interrupt handler for CT32B0. Used to toggle Haptics GPIOs based on struct
 *   Note speciications.
 *
 * \return None.
 */
void TIMER32_0_IRQHandler(void) {

	itHappened = true;

	// Check if interrupt was generated by Right haptic finishing high or
	//  low pulse
	if (Chip_TIMER_MatchPending(hapticTimer, getHapticMR(R_HAPTIC))) {
		Chip_TIMER_ClearMatch(hapticTimer, getHapticMR(R_HAPTIC));
		nextHapticState(R_HAPTIC);
	}

	// Check if interrupt was generated by Left haptic finishing high or
	//  low pulse
	if (Chip_TIMER_MatchPending(hapticTimer, getHapticMR(R_HAPTIC))) {
		Chip_TIMER_ClearMatch(hapticTimer, getHapticMR(R_HAPTIC));
		nextHapticState(L_HAPTIC);
	}
}

/**
 * Initialization that needs to happen for haptics to work.
 * 
 * \return None.
 */
void initHaptics(void) {
	Chip_GPIO_WritePortBit(LPC_GPIO, GPIO_HAPTICS_EN_N, true);
	Chip_GPIO_WriteDirBit(LPC_GPIO, GPIO_HAPTICS_EN_N, true);
	Chip_IOCON_PinMux(LPC_IOCON, GPIO_HAPTICS_EN_N, IOCON_MODE_PULLDOWN, 
		IOCON_FUNC0);

	Chip_GPIO_WritePortBit(LPC_GPIO, GPIO_HAPTICS_L, false);
	Chip_GPIO_SetPinDIROutput(LPC_GPIO, GPIO_HAPTICS_L);
	Chip_IOCON_PinMux(LPC_IOCON, GPIO_HAPTICS_L, IOCON_DIGMODE_EN, 
		IOCON_FUNC0);

	Chip_GPIO_WritePortBit(LPC_GPIO, GPIO_HAPTICS_R, false);
	Chip_GPIO_SetPinDIROutput(LPC_GPIO, GPIO_HAPTICS_R);
	Chip_IOCON_PinMux(LPC_IOCON, GPIO_HAPTICS_R, IOCON_DIGMODE_EN, 
		IOCON_FUNC0);

	Chip_GPIO_WritePortBit(LPC_GPIO, GPIO_HAPTICS_EN_N, false);

	Chip_TIMER_Init(hapticTimer);

	// Set the timer to increment every nanosecond
	Chip_TIMER_PrescaleSet(hapticTimer, SystemCoreClock/1000000);

	// Set priority of Timer IRQ to max
	NVIC_SetPriority(TIMER_32_0_IRQn, 0);
	
	// Clear interrup pending for Timer IRQ
	NVIC_ClearPendingIRQ(TIMER_32_0_IRQn);

	// Enable Timer interrupt
	NVIC_EnableIRQ(TIMER_32_0_IRQn);

//	Chip_TIMER_Reset(hapticTimer);

//	Chip_TIMER_Enable(hapticTimer);

	//TODO: play startup jingle
}

/**
 * Prints details to console regarding how to use the haptic command line 
 *  function.
 *
 * \return None.
 */
void hapticCmdUsage(void) {
	//TODO
}

/**
 * Handle Haptic control command line function.
 *
 * \param argc Number of arguments (i.e. size of argv)
 * \param argv Command line entry broken into array argument strings.
 *
 * \return 0 on success.
 */
int hapticCmdFnc(int argc, const char* argv[]) {
	//TODO: do this right

	static Note note;

	if (argc != 4) {

		consolePrint("Wrong number args!\n");
		
		return -1;
	}

	consolePrint("%d %d 0x%x %d %d %d\n", itHappened, 
		hapticBusy[R_HAPTIC], 
		hapticNotes[R_HAPTIC], hapticRepeatCnt[R_HAPTIC], 
		hapticNotesIdx[R_HAPTIC], hapticNotesLen[R_HAPTIC]);
	consolePrint("IR = 0x%08x\n", hapticTimer->IR);
	consolePrint("TCR = 0x%08x\n", hapticTimer->TCR);
	consolePrint("TC = 0x%08x\n", hapticTimer->TC);
	consolePrint("PR = 0x%08x\n", hapticTimer->PR);
	consolePrint("PC = 0x%08x\n", hapticTimer->PC);
	consolePrint("MCR = 0x%08x\n", hapticTimer->MCR);
	consolePrint("MR[0] = 0x%08x\n", hapticTimer->MR[0]);
	consolePrint("MR[1] = 0x%08x\n", hapticTimer->MR[1]);
	consolePrint("MR[2] = 0x%08x\n", hapticTimer->MR[2]);
	consolePrint("MR[3] = 0x%08x\n", hapticTimer->MR[3]);
	consolePrint("%d\n", SystemCoreClock);

	uint32_t hiDur = strtol(argv[1], NULL, 0);
	uint32_t loDur = strtol(argv[2], NULL, 0);
	uint32_t repeatCnt = strtol(argv[3], NULL, 0);

	note.highDuration = hiDur;
	note.lowDuration = loDur;
	note.repeatCnt = repeatCnt;

	playHaptic(R_HAPTIC, &note, 1);

	return 0;
}

/**
 * Initiate playing a sequence of notes via a particular haptic.
 *
 * Note: The notes buffer must persist until the sequence is finished playing
 *	(which will be after this returns). Don't put this on the stack!
//TODO: It is dangerous that buffer must persist beyond function exit... Figure out a better way or split into two functions (i.e. add one that copies)!
 * 
 * \param haptic Defines which haptic is being referred to.
 * \param[in] notes Buffer containing a sequence of notes to be played.
 * \param numNotes The number of notes in the notes buffer.
 *
 * \return 0 on sucess.
 */
int playHaptic(enum Haptic haptic, const struct Note* notes, uint32_t numNotes) {
	if (hapticBusy[haptic]) {
		return -1;
	}

	hapticBusy[haptic] = true;
	hapticNotes[haptic] = notes;
	hapticRepeatCnt[haptic] = 0;
	hapticNotesIdx[haptic] = 0;
	hapticNotesLen[haptic] = numNotes;

	Chip_TIMER_ClearMatch(hapticTimer, getHapticMR(haptic));

	// Drive haptic high for desired time
	setHapticGpioState(haptic, true);
	// Setup interrupt to occur when high portion is done
	hapticTimer->MR[getHapticMR(haptic)] = 
		notes[hapticNotesIdx[haptic]].highDuration + 
		Chip_TIMER_ReadCount(hapticTimer);

//TODO: need to protect this with lock mechanism?
	Chip_TIMER_MatchEnableInt(hapticTimer, getHapticMR(haptic));

	Chip_TIMER_Enable(hapticTimer);

	return 0;
}

