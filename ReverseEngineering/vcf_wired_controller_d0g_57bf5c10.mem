/**
 * This file attempts to track memory/variable usage and purpose for 
 *  vcf_wired_controller_d0g_57bf5c10.bin. This data was obtained via exeLog 
 *  outputs from pinkySim.
 *
 * MIT License
 *
 * Copyright (c) 2018 Gregory Gluszek
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

USB_HID0 HID Report Descriptor (len 0x41):
0x0000eeaa - 0x0000eeea
	 HID_UsagePage(HID_USAGE_PAGE_GENERIC)
	 HID_Usage(HID_USAGE_GENERIC_KEYBOARD)
	 HID_ReportCount(1)
	 HID_Collection(HID_Application)
	 HID_UsagePage(HID_USAGE_PAGE_KEYBOARD)
	 HID_UsageMin(224)
	 HID_UsageMax(231)
	 HID_LogicalMin(0)
	 HID_LogicalMax(1)
	 HID_ReportSize(1)
	 HID_ReportCount(8)
	 HID_Input(HID_Variable) // 0x02
	 HID_ReportCount(1)
	 HID_ReportSize(8)
	 HID_Input(HID_Constant) // 0x01
	 HID_ReportCount(5)
	 HID_ReportSize(1)
	 HID_UsagePage(HID_USAGE_PAGE_LED)
	 HID_UsageMin(1)
	 HID_UsageMax(5)
	 HID_Output(HID_Variable)
	 HID_ReportCount(1)
	 HID_ReportSize(3)
	 HID_Output(HID_Constant)
	 HID_ReportCount(6)
	 HID_ReportSize(8)
	 HID_LogicalMin(0)
	 HID_LogicalMax(101)
	 HID_UsagePage(HID_USAGE_PAGE_KEYBOARD)
	 HID_UsageMin(0)
	 HID_UsageMax(101)
	 HID_Input(HID_Data) // 0x00
	 HID_EndCollection

USB_HID1 HID Report Descriptor (len 0x34):
0x0000ee74 - 0x0000eea7
	HID_UsagePage(HID_USAGE_PAGE_GENERIC)
	HID_Usage(HID_USAGE_GENERIC_MOUSE)
	HID_Collection(HID_Application)
	HID_Usage(HID_USAGE_GENERIC_POINTER)
	HID_Collection(HID_Physical)
	HID_UsagePage(HID_USAGE_PAGE_BUTTON)
	HID_UsageMin(1)
	HID_UsageMax(5)
	HID_LogicalMin(0)
	HID_LogicalMax(1)
	HID_ReportCount(5)
	HID_ReportSize(1)
	HID_Input(HID_Variable) // 0x02
	HID_ReportCount(1)
	HID_ReportSize(3)
	HID_Input(HID_Constant) // 0x01
	HID_UsagePage(HID_USAGE_PAGE_GENERIC)
	HID_Usage(HID_USAGE_GENERIC_X)
	HID_Usage(HID_USAGE_GENERIC_Y)
	HID_Usage(HID_USAGE_GENERIC_WHEEL)
	HID_LogicalMin(-127)
	HID_LogicalMax(127)
	HID_ReportSize(8)
	HID_ReportCount(3)
	HID_Input(HID_Relative | HID_Variable) // 0x06
	HID_EndCollection

USB_HID2 HID Report Descriptor (len 0x21):
0x0000eeee - 0x0000ef0e
	HID_UsagePageVendor(HID_USAGE_PAGE_UNDEFINED)
	HID_Usage(HID_USAGE_GENERIC_POINTER)
	HID_Collection(HID_Application)
	HID_LogicalMin(0)
	HID_LogicalMaxS(255)
	HID_ReportSize(8)
	HID_ReportCount(64)
	HID_Usage(HID_USAGE_GENERIC_POINTER)
	HID_Input(HID_Variable) // 0x02
	HID_ReportCount(64)
	HID_Usage(HID_USAGE_GENERIC_POINTER)
	HID_Output(HID_Variable) // 0x02
	HID_ReportSize(64)
	HID_Output(HID_Constant) // 0x01
	HID_Feature(HID_Variable) // 0x02
	HID_EndCollection

 (uint8_t*) 0x10000000 - Related to CT16B0
 (uint8_t*) 0x10000001 - Flag to indicate CT16B0 interrupt has fired and been
			 handled.
 (uint8_t*) 0x10000002 - Counter variable? Related to CT16B1?
 (uint8_t*) 0x10000003 - Related to CT16B1?
 (uint8_t*) 0x10000004 - Related to CT16B1?
 (uint8_t*) 0x10000005 - Counter variable? Related to CT16B1?

 (uint8_t*) 0x10000008 - GPIO Bank/Group for TODO GPIO (PIO1_28)
 (uint8_t*) 0x10000009 - GPIO Number for TODO GPIO (PIO1_28)     
 (uint8_t*) 0x1000000a - GPIO Bank/Group for TODO GPIO (PIO0_7)
 (uint8_t*) 0x1000000b - GPIO Number for TODO GPIO (PIO0_7)     

 (uint8_t*) 0x10000010 - Flag related to ADC ISR. For DR6 case this indicates
			 ADC chnanel 6 has been sampled 8 times.
 (uint8_t*) 0x10000011 - Checked in ADC ISR (if 0x10000018 is 8). Maybe ADC 
			 clock is not disabled if this is not set?
 (uint8_t*) 0x10000012 - Set bits indicate which ADC channel is active (i.e. 
			 bit 6 for AD6).

(uint32_t*) 0x10000014 - ADC ISR initial delay counter. ADC ISR will run ~300
			 times (clearing ADC Data Register status bits) before
			 before any data is actually recorded. Some sort of 
			 delay to make sure whatever is being measured comes
			 into a steady or known state perhaps?
(uint32_t*) 0x10000018 - ADC ISR sample counter. (For DR6 case) counts up to 8
			 before 0x10000010 flag is set.

 (uint8_t*) 0x1000001c - GPIO Bank/Group for Joystick Power GPIO (PIO0_19)
 (uint8_t*) 0x1000001d - GPIO Number for Joystick Power GPIO (PIO0_19)
 (uint8_t*) 0x1000001e - Related to Joystick?

 (uint8_t*) 0x10000023 - AD channel number for joystick X position
 (uint8_t*) 0x10000024 - AD channel number for joystick Y position

(uint16_t*) 0x10000036 - Related to Joystick X position?
(uint16_t*) 0x10000038 - Related to Joystick Y position?
(uint16_t*) 0x1000003a - Related to Joystick X position?
(uint16_t*) 0x1000003c - Related to Joystick X position?
(uint16_t*) 0x1000003e - Related to Joystick X position?
(uint16_t*) 0x10000040 - Related to Joystick Y position?

 (uint8_t*) 0x10000044 - CT16B1 related?
 (uint8_t*) 0x10000045 - Defines which MAT to enable PWM mode for. (i.e. n in
			 CT16B1_MATn).

 (uint8_t*) 0x10000047 - Related to CT16B1? Timer number (i.e. n in C16TBn?)
(uint16_t*) 0x10000048 - Related to CT16B1?
(uint16_t*) 0x1000004a - CT16B1 related?
(uint16_t*) 0x1000004c - CT16B1 related?
(uint16_t*) 0x1000004e - CT16B1 related?
(uint32_t*) 0x10000050 - Base address for timer/counter related to Steam Button
			 LED (CT16B1).
(uint32_t*) 0x10000054 - Related to C16B1? Callback function of some sort?
(uint32_t*) 0x10000058 - CT16B1 related?
(uint32_t*) 0x1000005c - CT16B1 related?
 (uint8_t*) 0x10000060 - Bank/Group for TODO GPIO (PIO1_24) (Radio/USART?)
 (uint8_t*) 0x10000061 - GPIO Number for TODO Power GPIO (PIO1_24) (Radio/USART?)
 (uint8_t*) 0x10000062 - Bank/Group for TODO GPIO (PIO1_8) (Radio/USART?)
 (uint8_t*) 0x10000063 - GPIO Number for TODO Power GPIO (PIO1_8) (Radio/USART?)

 (uint8_t*) 0x10000074 - Related to USB being connected or maybe WWDT? Flag set
			 by SysTick handler after a certain number of 
			 executions.

(uint16_t*) 0x10000080 - USB_HID_REPORT_T field for HID EP1
			  uint16_t len; /**< Size of the report descriptor in bytes. */ 
 (uint8_t*) 0x10000082 - USB_HID_REPORT_T field for HID EP1
			  uint8_t idle_time; /**< This value is used by stack to respond to Set_Idle & 
					     GET_Idle requests for the specified report ID. The value
					     of this field specified the rate at which duplicate reports 
					     are generated for the specified Report ID. For example, a 
					     device with two input reports could specify an idle rate of 
					     20 milliseconds for report ID 1 and 500 milliseconds for 
					     report ID 2.
					     */
(uint32_t*) 0x10000084 - USB_HID_REPORT_T field for HID EP1
			  uint8_t* desc; /**< Report descriptor. */
(uint32_t*) 0x10000088 - HID EP1 related?
(uint32_t*) 0x1000008c - HID EP1 related?

(uint32_t*) 0x10000094 - EEPROM Read Data 0x004 - Board/HW Revision Number

(uint32_t*) 0x100000a4 - System Clock Rate (CCLK) in Hz. (48000000 is calcualted
			 and stored here based on PLL settings, etc.).
(uint32_t*) 0x100000a8 - static struct i2c_interface i2c[0].ip
			 IP base address of the I2C device
(uint32_t*) 0x100000ac - static struct i2c_interface i2c[0].clk
			 Clock used by I2C
(uint32_t*) 0x100000b0 - static struct i2c_interface i2c[0].mEvent
			 Current active Master event handler
(uint32_t*) 0x100000b4 - static struct i2c_interface i2c[0].sEvent
			 Slave transfer events
(uint32_t*) 0x100000b8 - static struct i2c_interface i2c[0].mXfer
			 Current active xfer pointer
(uint32_t*) 0x100000bc - static struct i2c_interface i2c[0].sXfer
			 Pointer to store xfer when bus is busy
(uint32_t*) 0x100000c0 - static struct i2c_interface i2c[0].flags
			 Flags used by I2C master and slave

 (uint8_t*) 0x10000200 - GPIO Bank/Group for TODO GPIO (PIO1_7)
 (uint8_t*) 0x10000201 - GPIO Number for TODO GPIO (PIO1_7)

 (uint8_t*) 0x10000203 - GPIO Bank/Group for TODO (power related?) GPIO (PIO1_12)
 (uint8_t*) 0x10000204 - GPIO Bank/Group for TODO (power related?) GPIO (PIO0_18)
 (uint8_t*) 0x10000205 - GPIO Number for TODO (power related?) GPIO (PIO1_12)
 (uint8_t*) 0x10000206 - GPIO Number for TODO (power related?) GPIO (PIO0_18)


 (uint8_t*) 0x10000234 - Number of active haptics or haptics to configure.
			 Related to SSP0. Copy of 0x20000002.

 (uint8_t*) 0x10000236 - Bit number for SSP0 SYSAHBCLKCTRL clock enable/disable.

 (uint8_t*) 0x1000023a - GPIO group/port for Right Haptic Chip Select (PIO1_15).
 (uint8_t*) 0x1000023b - GPIO group/port for Left Haptic Chip Select (PIO1_6).
 (uint8_t*) 0x1000023c - GPIO number/offset for Right Haptic Chip Selet (PIO1_15).
 (uint8_t*) 0x1000023d - GPIO number/offset for Left Haptic Chip Selet (PIO1_6).
 (uint8_t*) 0x1000023e - GPIO group/port for Right Haptic Data Ready (PIO0_23)?
 (uint8_t*) 0x1000023f - GPIO group/port for Left Haptic Data Ready (PIO1_16)?
 (uint8_t*) 0x10000240 - GPIO number/offset for Right Haptic Data Ready (PIO0_23)?
 (uint8_t*) 0x10000241 - GPIO number/offset for Left Haptic Data Ready (PIO1_16)?

(uint32_t*) 0x10000250 - Related to interrupts being enabled/disabled. 
			 Incremented after after interrupt disable (via cps). 
			 Decremented (and checked to be 0) before interrupt 
			 enable (via cps). Ony used in early init?
(uint16_t*) 0x10000254 - 1. EEPROM Read Data 0x000 - Magic Number to indicate 
			 EEPROM has valid data (early init only)
			 2. SSP0 control register base address
(uint16_t*) 0x10000256 - EEPROM Read Data 0x002 - Continuation of Magic Number?
(uint32_t*) 0x10000258 - EEPROM Read Data 0x004 - Board/HW Revision Number

(uint32_t*) 0x10000260 - System Clock Frequency in Hz

 (uint8_t*) 0x10000281 - Flag related to ??

 (uint8_t*) 0x100002ac - GPIO Bank/Group for TODO (power/battery related?) GPIO 
			 (PIO1_10)
 (uint8_t*) 0x100002ad - GPIO Number/Offset for TODO GPIO (power/battery 
			 related?) (PIO1_10)
 (uint8_t*) 0x100002ae - Controls whether or not to invert output for TODO 
			 (power/battery related?) GPIO (PIO1_10)?
 (uint8_t*) 0x100002af - Indicates which AD channel is being sampled (related
			 to GPIO1_10?)

 (uint8_t*) 0x100002b0 - GPIO Bank/Group for PINT1 GPIO (PIO0_2)
 (uint8_t*) 0x100002b1 - GPIO Number for PINT1 GPIO (PIO0_2)
 (uint8_t*) 0x100002b2 - Inverted value of PINT1 GPIO (PIO0_2) read before 
			 setting up interrupt.
 (uint8_t*) 0x100002b3 - Related to power or battery or someting? If PIO1_12 is 
			 high, this is set to high. If PIO1_12 is low, this is 
			 set value of PIO0_18.

 (uint8_t*) 0x100002b4 - Checked on loop once init reaches a certain point...
			 Check if is equal to 0x100002b7. Also, checked if is
			 0 by fnc0x00005204().

 (uint8_t*) 0x100002b6 - Related to reading DR6?? Some sort of flag/bool?
 (uint8_t*) 0x100002b7 - Checked on loop once init reaches a certain point...
			 Check if is equal to 0x100002b4

(uint16_t*) 0x100002b8 - Voltage related to DR6 in mV? Checked if is greater 
			 than or equal to 0x000005dc if PIO0_2=1 during boot 
			 when USB_VBUS=0, PIO0_18=1, PIO1_12=1.

(uint32_t*) 0x100002bc - Function pointer. Called in PINT1. PINT1 GPIO = PIO0_2.

   (float*) 0x100002c0 - Multiplication value of 3.3 voltage related to 
			 converting DR6 ADC value.
(uint32_t*) 0x100002c4 - Counter. Related to next open position in array of
			 function pointers starting at 0x10000dd8.
(uint32_t*) 0x100002c8 - USB HID3 related? Related to SysTick 0x10000338 
			 counter incremented in SysTick exception handler.
(uint32_t*) 0x100002cc - Value calculated based on DR6 average value?? (DR6
			 ADC value converted to voltage level maybe?)

  (int8_t*) 0x100002d0 - GPIO group/base for active low Analog Trigger enable 
			 (GPIO1_1)
  (int8_t*) 0x100002d1 - GPIO num/offset for active low Analog Trigger enable
			 (GPIO1_1)
  (int8_t*) 0x100002d2 - Related to JTAG TDI_PIO0_11 MODE settings?
  (int8_t*) 0x100002d3 - Related to JTAG TDO_PIO0_13 MODE settings?
  (int8_t*) 0x100002d4 - Related to JTAG TDI_PIO0_11 setup?
  (int8_t*) 0x100002d5 - Related to JTAG TDO_PIO0_13 setup?

  (int8_t*) 0x100002d8 - Related to PendSV? (Possibly) Cleared in PendSV.

 (uint8_t*) 0x100002db - Circular UART TX Buffer read pointer?
			 Checked in USB_Configure_Event...
 (uint8_t*) 0x100002dc - Circular UART TX Buffer write pointer?
 (uint8_t*) 0x100002dd - Counts how many bytes are queued in USART TX FIFO?
			 Checked in USB_Configure_Event...
 (uint8_t*) 0x100002de - Related to USART (Radio)? Checked in PendSV.
(uint32_t*) 0x100002e0 - Fnc Pointer/callback. Called in PendSV. Also related
			 to USART (Radio)?
 (uint8_t*) 0x100002e4 - Related to USART (Radio)?

(uint32_t*) 0x100002f4 = Related to USART (Radio)? 

 (uint8_t*) 0x10000310 - ADC channel (2) associated with TODO functionality
 (uint8_t*) 0x10000311 - ADC channel (0) associated with TODO functionality

(uint32_t*) 0x1000031c - Related to ADC Channel 0/2?

(uint16_t*) 0x10000324 - Related to SysTick. Counts up to 9 and then sets
			 0x10000074 flag and clears.
(uint16_t*) 0x10000326 - Related to SysTick? Counter realted to real-time 
			 (i.e. calculating 1 ms accurately...?)
(uint32_t*) 0x10000328 - Related to SysTick? Counter realted to real-time 
			 (i.e. calculating 1 ms accurately...?) Defines by
			 how much 0x10000330 and 0x10000324 increment each
			 tyime SysTick exception fires.
(uint32_t*) 0x1000032c - Related to SysTick? Counter realted to real-time 
			 (i.e. calculating 1 ms accurately...?)
(uint32_t*) 0x10000330 - Related to CT16B1? And/or SysTick? Counter realted to 
			 real-time (i.e. calculating 1 ms accurately...?)
(uint32_t*) 0x10000334 - Related to CT16B1? And/or SysTick? Counter realted to 
			 real-time (i.e. calculating 1 ms accurately...?)

(uint32_t*) 0x10000338 - USB HID3 related? Incremented in SysTick handler
			 after initial delay.
(uint32_t*) 0x1000033c - Function pointer for SysTick?

 (uint8_t*) 0x10000340 - Related to interrupts being enabled/disabled.
			 Incremented after after interrupt disable (via cps). 
			 Decremented (and checked to be 0) before interrupt 
			 enable (via cps).  (Similar to 0x10000250, but used 
			 after early init). Effectively a locking mechanism
			 (i.e. counting semaphore).

(uint32_t*) 0x10000348 - Function pointer? Related to I2C or CT16B1?
(uint32_t*) 0x1000034c - USBD_HANDLE_T (is typedef void*)
(uint32_t*) 0x10000350 - (const USBD_API_T *)LPC_ROM_API->usbdApiBase (0x1fff1f24)
(uint32_t*) 0x10000354 - Tracks bottom of USB stack, as HID devices/eps are added 
		 	 (i.e. mem_base from last USBD init call)
(uint32_t*) 0x10000358 - Tracks USB stack memory available as HID devices/eps are added
			 (i.e. mem_size from last USBD init call)

(uint16_t*) 0x10000364 - HID EP2 related?
(uint16_t*) 0x10000368 - USB_HID_REPORT_T field for HID EP2
			  uint16_t len; /**< Size of the report descriptor in bytes. */ 
 (uint8_t*) 0x1000036a - USB_HID_REPORT_T field for HID EP2
			  uint8_t idle_time; /**< This value is used by stack to respond to Set_Idle & 
					     GET_Idle requests for the specified report ID. The value
					     of this field specified the rate at which duplicate reports 
					     are generated for the specified Report ID. For example, a 
					     device with two input reports could specify an idle rate of 
					     20 milliseconds for report ID 1 and 500 milliseconds for 
					     report ID 2.
					     */
(uint32_t*) 0x1000036c - USB_HID_REPORT_T field for HID EP2
			  uint8_t* desc; /**< Report descriptor. */

(uint32_t*) 0x10000380 - USB HID3 related?

(uint16_t*) 0x10000390 - USB_HID_REPORT_T field for HID EP3
			  uint16_t len; /**< Size of the report descriptor in bytes. */ 
 (uint8_t*) 0x10000392 - USB_HID_REPORT_T field for HID EP3
			  uint8_t idle_time; /**< This value is used by stack to respond to Set_Idle & 
					     GET_Idle requests for the specified report ID. The value
					     of this field specified the rate at which duplicate reports 
					     are generated for the specified Report ID. For example, a 
					     device with two input reports could specify an idle rate of 
					     20 milliseconds for report ID 1 and 500 milliseconds for 
					     report ID 2.
					     */
(uint32_t*) 0x10000394 - USB_HID_REPORT_T field for HID EP3
			  uint8_t* desc; /**< Report descriptor. */

(uint32_t*) 0x100007e8 - Related to CT16B0?

(uint32_t*) 0x10000818 - Related to CT16B0. Callback function? First entry in
			 array of callback functions?


(uint32_t*) 0x10000834 - Related to CT16B1 MR3??

(uint32_t*) 0x10000858 - Related to Joystick?
(uint32_t*) 0x1000085c - Related to Joystick?

(uint32_t*) 0x10000868 - Related to ADC Channel 2?
(uint32_t*) 0x1000086c - Related to ADC Channel 2?

(uint32_t*) 0x100008a8 - Related to ADC Channel 2?
(uint32_t*) 0x100008ac - Related to ADC Channel 2?
(uint32_t*) 0x100008b0 - Related to Joystick?
(uint32_t*) 0x100008b4 - Related to Joystick?

 (uint8_t*) 0x10000924 - Flag? related to S6 RT Button
 (uint8_t*) 0x10000925 - Flag? related to S3 LT Button
 (uint8_t*) 0x10000926 - Flag? related to S9 Y Button
 (uint8_t*) 0x10000927 - Flag? related to S4 B Button
 (uint8_t*) 0x10000928 - Flag? related to S7 X Button
 (uint8_t*) 0x10000929 - Flag? related to S1 A Button
 (uint8_t*) 0x1000092a - Flag? related to S10 Right Bumper Button
 (uint8_t*) 0x1000092b - Flag? related to S8 Left Bumper Button
 (uint8_t*) 0x1000092c - Flag? related to S2 Left Trackpad Click Button
 (uint8_t*) 0x1000092d - Flag? related to S19 Front Right Arrow Button
 (uint8_t*) 0x1000092e - Flag? related to S18 Steam Button
 (uint8_t*) 0x1000092f - Flag? related to S17 Front Left Arrow Button
 (uint8_t*) 0x10000930 - Flag? related to ?? Button
 (uint8_t*) 0x10000931 - Flag? related to ?? Button
 (uint8_t*) 0x10000932 - Flag? related to ?? Button
 (uint8_t*) 0x10000933 - Flag? related to ?? Button
 (uint8_t*) 0x10000934 - Flag? related to ?? Button
 (uint8_t*) 0x10000935 - Flag? related to ?? Button
 (uint8_t*) 0x10000936 - Flag? related to ?? Button
 (uint8_t*) 0x10000937 - Flag? related to ?? Button
 (uint8_t*) 0x10000938 - Flag? related to S14 Left Inner Grip Button
 (uint8_t*) 0x10000939 - Flag? related to S16 Right Inner Grip Button
 (uint8_t*) 0x1000093a - Flag? related to ?? Button
 (uint8_t*) 0x1000093b - Flag? related to ?? Button
 (uint8_t*) 0x1000093c - Flag? related to ?? Button
 (uint8_t*) 0x1000093d - Flag? related to ?? Button
 (uint8_t*) 0x1000093e - Flag? related to ?? Button
 (uint8_t*) 0x1000093f - Flag? related to ?? Button
 (uint8_t*) 0x10000940 - Flag? related to ?? Button
 (uint8_t*) 0x10000941 - Flag? related to ?? Button
 (uint8_t*) 0x10000942 - Flag? related to ?? Button
 (uint8_t*) 0x10000943 - Flag? related to ?? Button
 (uint8_t*) 0x10000944 - Flag? related to ?? Button
 (uint8_t*) 0x10000945 - Flag? related to ?? Button
 (uint8_t*) 0x10000946 - Flag? related to ?? Button
 (uint8_t*) 0x10000947 - Flag? related to ?? Button
 (uint8_t*) 0x10000948 - Flag? related to ?? Button
 (uint8_t*) 0x10000949 - Flag? related to ?? Button
 (uint8_t*) 0x1000094a - Flag? related to ?? Button
 (uint8_t*) 0x1000094b - Flag? related to ?? Button
 (uint8_t*) 0x1000094c - Flag? related to ?? Button
 (uint8_t*) 0x1000094d - Flag? related to ?? Button
 (uint8_t*) 0x1000094e - Flag? related to S? Analog Joystick Click Button
 (uint8_t*) 0x1000094f - Flag? related to S5 Right Trackpad Click Button
 (uint8_t*) 0x10000950 - Flag? related to ?? Button
 (uint8_t*) 0x10000951 - Flag? related to ?? Button
 (uint8_t*) 0x10000952 - Flag? related to ?? Button
 (uint8_t*) 0x10000953 - S6 Right Trigger Button GPIO group/base
 (uint8_t*) 0x10000954 - S6 Right Trigger Button GPIO num/offset
 (uint8_t*) 0x10000955 - S3 Left Trigger Button GPIO group/base
 (uint8_t*) 0x10000956 - S3 Left Trigger Button GPIO num/offset
 (uint8_t*) 0x10000957 - S9 Y Button GPIO group/base
 (uint8_t*) 0x10000958 - S9 Y Button GPIO num/offset
 (uint8_t*) 0x10000959 - S4 B Button GPIO group/base
 (uint8_t*) 0x1000095a - S4 B Button GPIO num/offset
 (uint8_t*) 0x1000095b - S7 X Button GPIO group/base
 (uint8_t*) 0x1000095c - S7 X Button GPIO num/offset
 (uint8_t*) 0x1000095d - S1 A Button GPIO group/base
 (uint8_t*) 0x1000095e - S1 A Button GPIO num/offset
 (uint8_t*) 0x1000095f - S10 Right Bumper Button GPIO group/base
 (uint8_t*) 0x10000960 - S10 Right Bumper Button GPIO num/offset
 (uint8_t*) 0x10000961 - S8 Left Bumper Button GPIO group/base
 (uint8_t*) 0x10000962 - S8 Left Bumper Button GPIO num/offset
 (uint8_t*) 0x10000963 - S2 Left Trackpad Click Button GPIO group/base
 (uint8_t*) 0x10000964 - S2 Left Trackpad Click Button GPIO num/offset
 (uint8_t*) 0x10000965 - S19 Front Right Arrow Button GPIO group/base
 (uint8_t*) 0x10000966 - S19 Front Right Arrow Button Button GPIO num/offset
 (uint8_t*) 0x10000967 - S? Steam Button GPIO group/base
 (uint8_t*) 0x10000968 - S? Steam Button Button GPIO num/offset
 (uint8_t*) 0x10000969 - S17 Front Left Arrow Button GPIO group/base
 (uint8_t*) 0x1000096a - S17 Front Left Arrow Button Button GPIO num/offset

 (uint8_t*) 0x1000097b - S14 Left Inner Grip Button GPIO group/base
 (uint8_t*) 0x1000097c - S14 Left Inner Grip Button Button GPIO num/offset
 (uint8_t*) 0x1000097d - S16 Right Inner Grip Button GPIO group/base
 (uint8_t*) 0x1000097e - S16 Right Inner Grip Button Button GPIO num/offset

 (uint8_t*) 0x100009a7 - S? Analog Joystick Click Button GPIO group/base
 (uint8_t*) 0x100009a8 - S? Analog Joystick Click Button Button GPIO num/offset
 (uint8_t*) 0x100009a9 - S5 Right Trackpad Click Button GPIO group/base
 (uint8_t*) 0x100009aa - S5 Right Trackpad Click Button Button GPIO num/offset

(uint16_t*) 0x100009b4 - EEPROM Read Data 0x000 - Magic Number to indicate 
			 EEPROM has valid data
(uint16_t*) 0x100009b6 - EEPROM Read Data 0x002 - Continuation of Magic Number?
(uint32_t*) 0x100009b8 - EEPROM Read Data 0x004 - Board/HW Revision Number
 (uint8_t*) 0x100009b9 - EEPROM Read Data 0x005 - Uknown purpose
 (uint8_t*) 0x100009ba - EEPROM Read Data 0x006 - Uknown purpose
 (uint8_t*) 0x100009bb - EEPROM Read Data 0x007 - Uknown purpose
 (uint8_t*) 0x100009bc - EEPROM Read Data 0x008 - Uknown purpose
 (uint8_t*) 0x100009bd - EEPROM Read Data 0x009 - Uknown purpose
 (uint8_t*) 0x100009be - EEPROM Read Data 0x00a - Uknown purpose
 (uint8_t*) 0x100009bf - EEPROM Read Data 0x00b - Uknown purpose
 (uint8_t*) 0x100009c0 - EEPROM Read Data 0x00c - Uknown purpose
 (uint8_t*) 0x100009c1 - EEPROM Read Data 0x00d - Uknown purpose
 (uint8_t*) 0x100009c2 - EEPROM Read Data 0x00e - Uknown purpose
 (uint8_t*) 0x100009c3 - EEPROM Read Data 0x00f - Uknown purpose
 (uint8_t*) 0x100009c4 - EEPROM Read Data 0x010 - Uknown purpose
 (uint8_t*) 0x100009c5 - EEPROM Read Data 0x011 - Uknown purpose
 (uint8_t*) 0x100009c6 - EEPROM Read Data 0x012 - Uknown purpose
 (uint8_t*) 0x100009c7 - EEPROM Read Data 0x013 - Uknown purpose
 (uint8_t*) 0x100009c8 - EEPROM Read Data 0x014 - Uknown purpose
 (uint8_t*) 0x100009c9 - EEPROM Read Data 0x015 - Uknown purpose
 (uint8_t*) 0x100009ca - EEPROM Read Data 0x016 - Uknown purpose
 (uint8_t*) 0x100009cb - EEPROM Read Data 0x017 - Uknown purpose
 (uint8_t*) 0x100009cc - EEPROM Read Data 0x018 - Uknown purpose
 (uint8_t*) 0x100009cd - EEPROM Read Data 0x019 - Uknown purpose
 (uint8_t*) 0x100009ce - EEPROM Read Data 0x01a - Uknown purpose
 (uint8_t*) 0x100009cf - EEPROM Read Data 0x01b - Uknown purpose
 (uint8_t*) 0x100009d0 - EEPROM Read Data 0x01c - Uknown purpose
 (uint8_t*) 0x100009d1 - EEPROM Read Data 0x01d - Uknown purpose
 (uint8_t*) 0x100009d2 - EEPROM Read Data 0x01e - Uknown purpose
 (uint8_t*) 0x100009d3 - EEPROM Read Data 0x01f - Uknown purpose
 (uint8_t*) 0x100009d4 - EEPROM Read Data 0x020 - Uknown purpose
 (uint8_t*) 0x100009d5 - EEPROM Read Data 0x021 - Uknown purpose
 (uint8_t*) 0x100009d6 - EEPROM Read Data 0x022 - Uknown purpose
 (uint8_t*) 0x100009d7 - EEPROM Read Data 0x023 - Uknown purpose
 (uint8_t*) 0x100009d8 - EEPROM Read Data 0x024 - Uknown purpose
 (uint8_t*) 0x100009d9 - EEPROM Read Data 0x025 - Uknown purpose
 (uint8_t*) 0x100009da - EEPROM Read Data 0x026 - Uknown purpose
 (uint8_t*) 0x100009db - EEPROM Read Data 0x027 - Uknown purpose
 (uint8_t*) 0x100009dc - EEPROM Read Data 0x028 - Uknown purpose
 (uint8_t*) 0x100009dd - EEPROM Read Data 0x029 - Uknown purpose
 (uint8_t*) 0x100009de - EEPROM Read Data 0x02a - Uknown purpose
 (uint8_t*) 0x100009df - EEPROM Read Data 0x02b - Uknown purpose
 (uint8_t*) 0x100009e0 - EEPROM Read Data 0x02c - Uknown purpose
 (uint8_t*) 0x100009e1 - EEPROM Read Data 0x02d - Uknown purpose
 (uint8_t*) 0x100009e2 - EEPROM Read Data 0x02e - Uknown purpose
 (uint8_t*) 0x100009e3 - EEPROM Read Data 0x02f - Uknown purpose
 (uint8_t*) 0x100009e4 - EEPROM Read Data 0x030 - Uknown purpose
 (uint8_t*) 0x100009e5 - EEPROM Read Data 0x031 - Uknown purpose
 (uint8_t*) 0x100009e6 - EEPROM Read Data 0x032 - Uknown purpose
 (uint8_t*) 0x100009e7 - EEPROM Read Data 0x033 - Uknown purpose
(uint16_t*) 0x100009e8 - EEPROM Read Data 0x034 - Related to Joystick?
(uint16_t*) 0x100009ea - EEPROM Read Data 0x036 - Related to Joystick?
 (uint8_t*) 0x100009ec - EEPROM Read Data 0x038 - Uknown purpose
 (uint8_t*) 0x100009ed - EEPROM Read Data 0x039 - Uknown purpose
 (uint8_t*) 0x100009ee - EEPROM Read Data 0x03a - Uknown purpose
 (uint8_t*) 0x100009ef - EEPROM Read Data 0x03b - Uknown purpose
 (uint8_t*) 0x100009f0 - EEPROM Read Data 0x03c - Uknown purpose
 (uint8_t*) 0x100009f1 - EEPROM Read Data 0x03d - Uknown purpose
 (uint8_t*) 0x100009f2 - EEPROM Read Data 0x03e - Uknown purpose
 (uint8_t*) 0x100009f3 - EEPROM Read Data 0x03f - Uknown purpose
 (uint8_t*) 0x100009f4 - EEPROM Read Data 0x040 - Uknown purpose
 (uint8_t*) 0x100009f5 - EEPROM Read Data 0x041 - Uknown purpose
 (uint8_t*) 0x100009f6 - EEPROM Read Data 0x042 - Uknown purpose
 (uint8_t*) 0x100009f7 - EEPROM Read Data 0x043 - Uknown purpose
 (uint8_t*) 0x100009f8 - EEPROM Read Data 0x044 - Uknown purpose
 (uint8_t*) 0x100009f9 - EEPROM Read Data 0x045 - Uknown purpose
 (uint8_t*) 0x100009fa - EEPROM Read Data 0x046 - Uknown purpose
 (uint8_t*) 0x100009fb - EEPROM Read Data 0x047 - Uknown purpose
 (uint8_t*) 0x100009fc - EEPROM Read Data 0x048 - Uknown purpose
 (uint8_t*) 0x100009fd - EEPROM Read Data 0x049 - Uknown purpose
 (uint8_t*) 0x100009fe - EEPROM Read Data 0x04a - Uknown purpose
 (uint8_t*) 0x100009ff - EEPROM Read Data 0x04b - Uknown purpose
 (uint8_t*) 0x10000a00 - EEPROM Read Data 0x04c - Uknown purpose
 (uint8_t*) 0x10000a01 - EEPROM Read Data 0x04d - Uknown purpose
 (uint8_t*) 0x10000a02 - EEPROM Read Data 0x04e - Uknown purpose
 (uint8_t*) 0x10000a03 - EEPROM Read Data 0x04f - Uknown purpose
 (uint8_t*) 0x10000a04 - EEPROM Read Data 0x050 - Uknown purpose
 (uint8_t*) 0x10000a05 - EEPROM Read Data 0x051 - Uknown purpose
 (uint8_t*) 0x10000a06 - EEPROM Read Data 0x052 - Uknown purpose
 (uint8_t*) 0x10000a07 - EEPROM Read Data 0x053 - Uknown purpose
 (uint8_t*) 0x10000a08 - EEPROM Read Data 0x054 - Uknown purpose
 (uint8_t*) 0x10000a09 - EEPROM Read Data 0x055 - Uknown purpose
 (uint8_t*) 0x10000a0a - EEPROM Read Data 0x056 - Uknown purpose
 (uint8_t*) 0x10000a0b - EEPROM Read Data 0x057 - Uknown purpose
 (uint8_t*) 0x10000a0c - EEPROM Read Data 0x058 - Uknown purpose
 (uint8_t*) 0x10000a0d - EEPROM Read Data 0x059 - Uknown purpose
 (uint8_t*) 0x10000a0e - EEPROM Read Data 0x05a - Uknown purpose
 (uint8_t*) 0x10000a0f - EEPROM Read Data 0x05b - Uknown purpose
 (uint8_t*) 0x10000a10 - EEPROM Read Data 0x05c - Uknown purpose
 (uint8_t*) 0x10000a11 - EEPROM Read Data 0x05d - Uknown purpose
 (uint8_t*) 0x10000a12 - EEPROM Read Data 0x05e - Uknown purpose
 (uint8_t*) 0x10000a13 - EEPROM Read Data 0x05f - Uknown purpose
 (uint8_t*) 0x10000a14 - EEPROM Read Data 0x060 - Uknown purpose
 (uint8_t*) 0x10000a15 - EEPROM Read Data 0x061 - Uknown purpose
 (uint8_t*) 0x10000a16 - EEPROM Read Data 0x062 - Uknown purpose
 (uint8_t*) 0x10000a17 - EEPROM Read Data 0x063 - Uknown purpose
 (uint8_t*) 0x10000a18 - EEPROM Read Data 0x064 - Uknown purpose
 (uint8_t*) 0x10000a19 - EEPROM Read Data 0x065 - Uknown purpose
 (uint8_t*) 0x10000a1a - EEPROM Read Data 0x066 - Uknown purpose
 (uint8_t*) 0x10000a1b - EEPROM Read Data 0x067 - Uknown purpose
 (uint8_t*) 0x10000a1c - EEPROM Read Data 0x068 - Uknown purpose
 (uint8_t*) 0x10000a1d - EEPROM Read Data 0x069 - Uknown purpose
 (uint8_t*) 0x10000a1e - EEPROM Read Data 0x06a - Uknown purpose
 (uint8_t*) 0x10000a1f - EEPROM Read Data 0x06b - Uknown purpose
 (uint8_t*) 0x10000a20 - EEPROM Read Data 0x06c - Uknown purpose
 (uint8_t*) 0x10000a21 - EEPROM Read Data 0x06d - Uknown purpose
 (uint8_t*) 0x10000a22 - EEPROM Read Data 0x06e - Uknown purpose
 (uint8_t*) 0x10000a23 - EEPROM Read Data 0x06f - Uknown purpose
 (uint8_t*) 0x10000a24 - EEPROM Read Data 0x070 - Uknown purpose
 (uint8_t*) 0x10000a25 - EEPROM Read Data 0x071 - Uknown purpose
 (uint8_t*) 0x10000a26 - EEPROM Read Data 0x072 - Uknown purpose
 (uint8_t*) 0x10000a27 - EEPROM Read Data 0x073 - Uknown purpose
 (uint8_t*) 0x10000a28 - EEPROM Read Data 0x074 - Power-on Jingle Index
 (uint8_t*) 0x10000a29 - EEPROM Read Data 0x075 - Power-off Jingle Index
 (uint8_t*) 0x10000a2a - EEPROM Read Data 0x076 - Uknown purpose
 (uint8_t*) 0x10000a2b - EEPROM Read Data 0x077 - Uknown purpose
 (uint8_t*) 0x10000a2c - EEPROM Read Data 0x078 - Uknown purpose
 (uint8_t*) 0x10000a2d - EEPROM Read Data 0x079 - Uknown purpose
 (uint8_t*) 0x10000a2e - EEPROM Read Data 0x07a - Uknown purpose
 (uint8_t*) 0x10000a2f - EEPROM Read Data 0x07b - Uknown purpose
 (uint8_t*) 0x10000a30 - EEPROM Read Data 0x07c - Uknown purpose
 (uint8_t*) 0x10000a31 - EEPROM Read Data 0x07d - Uknown purpose
 (uint8_t*) 0x10000a32 - EEPROM Read Data 0x07e - Uknown purpose
 (uint8_t*) 0x10000a33 - EEPROM Read Data 0x07f - Uknown purpose
 (uint8_t*) 0x10000a34 - EEPROM Read Data 0x080 - Uknown purpose
 (uint8_t*) 0x10000a35 - EEPROM Read Data 0x081 - Uknown purpose
 (uint8_t*) 0x10000a36 - EEPROM Read Data 0x082 - Uknown purpose
 (uint8_t*) 0x10000a37 - EEPROM Read Data 0x083 - Uknown purpose

 (uint8_t*) 0x10000d80 - I2C_XFER_T.slaveAddr; 7-bit I2C Slave address 

(uint32_t*) 0x10000d84 - I2C_XFER_T.txBuff; Pointer to array of bytes to be 
			 transmitted
(uint32_t*) 0x10000d88 - I2C_XFER_T.txSz; Number of bytes in transmit array,
			 if 0 only receive transfer will be carried on 
(uint32_t*) 0x10000d8c - I2C_XFER_T.rxBuff; Pointer memory where bytes 
			 received from I2C be stored 
(uint32_t*) 0x10000d90 - I2C_XFER_T.rxSz; Number of bytes to received,
			 if 0 only transmission we be carried on 
(uint32_t*) 0x10000d94 - I2C_XFER_T.status; Status of the current I2C transfer
 (uint8_t*) 0x10000d98 - I2C_XFER_T.txBuff[0]
 (uint8_t*) 0x10000d99 - I2C_XFER_T.txBuff[1]

(uint32_t*) 0x10000dd8 - First in array of function pointers (related to 
			 CT16B1?)
(uint32_t*) 0x10000ddc - Second in array of function pointers (related to 
			 Joystick X/Y and ADC?)
(uint32_t*) 0x10000de0 - Third in array of function pointers (related to 
			 Controller Buttons?)
(uint32_t*) 0x10000de4 - Fourth in array of function pointers (related to 
			 Radio/USART?)

 (uint8_t*) 0x10000f00 - Circular USART TX Buffer[0]. Used to queue TX Data 
			 for USART when USART (HW) TX FIFO is full?
 ...
 (uint8_t*) 0x10000f7f - Circular USART TX Buffer[127]. Used to queue TX Data 
			 for USART when USART (HW) TX FIFO is full?
(uint16_t*) 0x10000f80 - ADC Channel 0 accumulator.
(uint16_t*) 0x10000f82 - ADC Channel 1 accumulator.
(uint16_t*) 0x10000f84 - ADC Channel 2 accumulator.
(uint16_t*) 0x10000f86 - ADC Channel 3 accumulator.
(uint16_t*) 0x10000f88 - ADC Channel 4 accumulator?
(uint16_t*) 0x10000f8a - ADC Channel 5 accumulator?
(uint16_t*) 0x10000f8c - Accumulator V_VREF from DR6 (i.e. voltage on ADC 
			 channel 6).  Accumulation occurs in ADC ISR.
(uint16_t*) 0x10000f8e - ADC Channel 7 accumulator?

(uint32_t*) 0x10000f90 - Function pointer. Related to handling AD0 readings 
			 obtained via ISR. 
(uint32_t*) 0x10000f94 - Function pointer. Related to handling AD1 readings
			 obtained via ISR. 
(uint32_t*) 0x10000f98 - Function pointer. Related to handling AD2 readings
			 obtained via ISR. 
(uint32_t*) 0x10000f9c - Function pointer. Related to handling AD3 readings
			 obtained via ISR. 
(uint32_t*) 0x10000fa0 - Function pointer. Related to handling AD4 readings
			 obtained via ISR. 
(uint32_t*) 0x10000fa4 - Function pointer. Related to handling AD5 readings
			 obtained via ISR. 
(uint32_t*) 0x10000fa8 - Function pointer. Related to handling AD6 readings
			 obtained via ISR. 
(uint32_t*) 0x10000fac - Function pointer. Related to handling AD7 readings
			 obtained via ISR. 

(uint32_t*) 0x10000fb0 - Possible function pointer. Related to AD0?
(uint32_t*) 0x10000fb4 - Possible function pointer. Related to AD1?
(uint32_t*) 0x10000fb8 - Possible function pointer. Related to AD2?
(uint32_t*) 0x10000fbc - Possible function pointer. Related to AD3?
(uint32_t*) 0x10000fc0 - Possible function pointer. Related to AD4?
(uint32_t*) 0x10000fc4 - Possible function pointer. Related to AD5?
(uint32_t*) 0x10000fc8 - Function pointer. Executes code that checks P1_12 and 
			 (potentially) P0_18. Related to AD6.
(uint32_t*) 0x10000fcc - Possible function pointer. Related to AD7?

   (float*) 0x10000fd0 - Related to Joystick X (= 0.15). Written by
			 fnc0x0000963c(0x10000fd0, 0x1ff, 0x2c7, 3)
   (float*) 0x10000fd4 - Related to Joystick X (= 611.0). Written by
			 fnc0x0000963c(0x10000fd0, 0x1ff, 0x2c7, 3)
   (float*) 0x10000fd8 - Related to Joystick X (= 511.0). Written by
			 fnc0x0000963c(0x10000fd0, 0x1ff, 0x2c7, 3)
   (float*) 0x10000fdc - Related to Joystick X (= 711.0). Written by 
			 fnc0x0000963c(0x10000fd0, 0x1ff, 0x2c7, 3)
 (uint8_t*) 0x10000fe0 - Related to Joystick X. Written by
			 fnc0x0000963c(0x10000fd0, 0x1ff, 0x2c7, 3)

(uint16_t*) 0x10000fe2 - Related to Joystick X (= 3). Written by
			 fnc0x0000963c(0x10000fd0, 0x1ff, 0x2c7, 3)
   (float*) 0x10000fe4 - Related to Joystick X (= 511.0). Written by
			 fnc0x0000963c(0x10000fd0, 0x1ff, 0x2c7, 3)
   (float*) 0x10000fe8 - Related to Joystick X (= 0.0). Written by
			 fnc0x0000963c(0x10000fd0, 0x1ff, 0x2c7, 3)
   (float*) 0x10000fec - Related to Joystick X (= 711.0). Written by
			 fnc0x0000963c(0x10000fd0, 0x1ff, 0x2c7, 3)
   (float*) 0x10000ff0 - Related to Joystick X (= 0.0). Written by
			 fnc0x0000963c(0x10000fd0, 0x1ff, 0x2c7, 3)
   (float*) 0x10000ff4 - Related to Joystick X (= 0.15). Written by
			 fnc0x0000963c(0x10000ff4, 0x1ff, 0x137, 3)
   (float*) 0x10000ff8 - Related to Joystick X (= 411.0). Written by
			 fnc0x0000963c(0x10000ff4, 0x1ff, 0x137, 3)
   (float*) 0x10000ffc - Related to Joystick X (= 511.0). Written by
			 fnc0x0000963c(0x10000ff4, 0x1ff, 0x137, 3)
   (float*) 0x10001000 - Related to Joystick X (= 311.0). Written by 
			 fnc0x0000963c(0x10000ff4, 0x1ff, 0x137, 3)
 (uint8_t*) 0x10001004 - Related to Joystick X (= 1). Written by
			 fnc0x0000963c(0x10000ff4, 0x1ff, 0x137, 3)

(uint16_t*) 0x10001006 - Related to Joystick X (= 3). Written by
			 fnc0x0000963c(0x10000ff4, 0x1ff, 0x137, 3)
   (float*) 0x10001008 - Related to Joystick X (= 511.0). Written by
			 fnc0x0000963c(0x10000ff4, 0x1ff, 0x137, 3)
   (float*) 0x1000100c - Related to Joystick X (= 0.0). Written by
			 fnc0x0000963c(0x10000ff4, 0x1ff, 0x137, 3)
   (float*) 0x10001010 - Related to Joystick X (= 311.0). Written by
			 fnc0x0000963c(0x10000ff4, 0x1ff, 0x137, 3)
   (float*) 0x10001014 - Related to Joystick X (= 0.0). Written by
			 fnc0x0000963c(0x10000ff4, 0x1ff, 0x137, 3)
   (float*) 0x10001018 - Related to Joystick Y (= 0.15). Written by
			 fnc0x0000963c(0x10001018, 0x1f5, 0x2bd, 3)
   (float*) 0x1000101c - Related to Joystick Y (= 601.0). Written by
			 fnc0x0000963c(0x10001018, 0x1f5, 0x2bd, 3)
   (float*) 0x10001020 - Related to Joystick Y (= 501.0). Written by
			 fnc0x0000963c(0x10001018, 0x1f5, 0x2bd, 3)
   (float*) 0x10001024 - Related to Joystick Y (= 701.0). Written by 
			 fnc0x0000963c(0x10001018, 0x1f5, 0x2bd, 3)
 (uint8_t*) 0x10001028 - Related to Joystick Y (= 0). Written by
			 fnc0x0000963c(0x10001018, 0x1f5, 0x2bd, 3)

(uint16_t*) 0x1000102a - Related to Joystick Y (= 3). Written by
			 fnc0x0000963c(0x10001018, 0x1f5, 0x2bd, 3)
   (float*) 0x1000102c - Related to Joystick Y (= 501.0). Written by
			 fnc0x0000963c(0x10001018, 0x1f5, 0x2bd, 3)
   (float*) 0x10001030 - Related to Joystick Y (= 0.0). Written by
			 fnc0x0000963c(0x10001018, 0x1f5, 0x2bd, 3)
   (float*) 0x10001034 - Related to Joystick Y (= 701.0). Written by
			 fnc0x0000963c(0x10001018, 0x1f5, 0x2bd, 3)
   (float*) 0x10001038 - Related to Joystick Y (= 0.0). Written by
			 fnc0x0000963c(0x10001018, 0x1f5, 0x2bd, 3)
   (float*) 0x1000103c - Related to Joystick Y (= 0.15). Written by
			 fnc0x0000963c(0x1000103c, 0x1f5, 0x12d, 3)
   (float*) 0x10001040 - Related to Joystick Y (= 401.0). Written by
			 fnc0x0000963c(0x1000103c, 0x1f5, 0x12d, 3)
   (float*) 0x10001044 - Related to Joystick Y (= 501.0). Written by
			 fnc0x0000963c(0x1000103c, 0x1f5, 0x12d, 3)
   (float*) 0x10001048 - Related to Joystick Y (= 301.0). Written by 
			 fnc0x0000963c(0x1000103c, 0x1f5, 0x12d, 3)
 (uint8_t*) 0x1000104c - Related to Joystick Y (= 1). Written by
			 fnc0x0000963c(0x1000103c, 0x1f5, 0x12d, 3)

(uint16_t*) 0x1000104e - Related to Joystick Y (= 3). Written by
			 fnc0x0000963c(0x1000103c, 0x1f5, 0x12d, 3)
   (float*) 0x10001050 - Related to Joystick Y (= 501.0). Written by
			 fnc0x0000963c(0x1000103c, 0x1f5, 0x12d, 3)
   (float*) 0x10001054 - Related to Joystick Y (= 0.0). Written by
			 fnc0x0000963c(0x1000103c, 0x1f5, 0x12d, 3)
   (float*) 0x10001058 - Related to Joystick Y (= 301.0). Written by
			 fnc0x0000963c(0x1000103c, 0x1f5, 0x12d, 3)
   (float*) 0x1000105c - Related to Joystick Y (= 0.0). Written by
			 fnc0x0000963c(0x1000103c, 0x1f5, 0x12d, 3)

   (float*) 0x10001064 - Related to AD0/AD2 (trigger analog positions). 
			 Initialized to value 32767.0

   (float*) 0x10001088 - Related to AD0/AD2 (trigger analog positions). 
			 Initialized to value 32767.0

 (uint8_t*) 0x100010a8 - UKNOWN STRUCT A UNKNOWN FIELD D (initialized to 0x01) Related to USART (Radio). PINTSEL2 GPIO Bank/Group.
 (uint8_t*) 0x100010a9 - UKNOWN STRUCT A UNKNOWN FIELD F (initialized to 0x05) Related to USART (Radio). PINTSEL2 GPIO Number.
 (uint8_t*) 0x100010aa - UKNOWN STRUCT A UNKNOWN FIELD C (initialized to 0x01) Related to USART (Radio). RXD GPIO Bank/Group.
 (uint8_t*) 0x100010ab - UKNOWN STRUCT A UNKNOWN FIELD B (initialized to 0x11) Related to USART (Radio). RXD GPIO Number.
 (uint8_t*) 0x100010ac - UKNOWN STRUCT A UNKNOWN FIELD E (initialized to 0x01) Related to USART (Radio). TXD GPIO Bank/Group.
 (uint8_t*) 0x100010ad - UKNOWN STRUCT A UNKNOWN FIELD D (initialized to 0x12) Related to USART (Radio). TXD GPIO Number.
(uint32_t*) 0x100010b0 - UKNOWN STRUCT A UNKNOWN FIELD A (initialized to 0x000e1000) Related to USART (Radio). Baud Rate Maybe....?

(uint32_t*) 0x100010b4 - Callback function? Related to PIO0_3 (USB_VBUS) 
			 changing state (fnc0x000055e8()).
(uint32_t*) 0x100010b8 - Callback function. Related to PINT1 (PIO0_2 change).
(uint32_t*) 0x100010bc - Callback function. Related to PINT2 (PIO1_5 change).
			 Initially setup callback that does nothing... (at least
			 for USB_VBUS = 1 case...). Maybe just used to wakeup
			 processor in main loop from wfi?

(uint32_t*) 0x100010d8 - Related to USB callbacks? Interrupt disabled in order to check...


(uint16_t*) 0x10001140 - HID EP3 related?
 (uint8_t*) 0x10001142 - HID EP3 related?
 (uint8_t*) 0x10001143 - HID EP3 related?

(uint32_t*) 0x10001c2c - Callback related to USB_IRQ (if GPREG1 is 0).

  (int8_t*) 0x20000000 - Related to Haptics/SSP0?

 (uint8_t*) 0x20000002 - Number of active haptics or haptics to configure.
			 Related to SSP0

 (uint8_t*) 0x20000008 - Flag related to ??

 (uint8_t*) 0x20000075 - Counter?? Related to Joystick X/Y position?

(uint16_t*) 0x200002a2 - Related to CT16B1 MR0 calculation?

(uint32_t*) 0x200002c0 - Related to Joystick X/Y position? Callback?
