###############################################################################
# Command file for simulating Stream Controller firmware using pinkySim.
#
# Execute in gdb using "source" command.
#  For details refer to: https://sourceware.org/gdb/onlinedocs/gdb/Command-Files.html
#
# Note this was developed by simulating vcf_wired_controller_d0g_57bf5c10.bin,
#  and may not work properly with other firmware.
#
#  MIT License
# 
#  Copyright (c) 2017 Gregory Gluszek
# 
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
# 
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
# 
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
###############################################################################

#TODO: Can we add local gdb variables for defining behavior: 
#	USB cable present (PIO0_3 will read 1 if cable is present)
#	brown out detect (0x40048030)
#	simulating interrupt(s)
#	Other hw inputs?

# Note: standard breakpoints seem to be broken (gdb issue?) so instead 
#	watchpoints are set for $pc == instruction_addr. The main issue with 
#	this is that it makes execution slow while watchpoint is active and,
#	therefore, these types of watchpoints should be removed once they are
#	no longer needed


#------------------------------------------------------------------------------#
# Begin: Simulation Run Configuration Variables.                               #
#                                                                              #

# 32-bit word read from EEPROM byte offset 0xXXX (see MEM LAYOUT in 
#  vcf_wired_controller_d0g_57bf5c10.c for details on value significance):

set $eeprom_0x000 = 0x0005a55a 
set $eeprom_0x004 = 0x0000000a 
set $eeprom_0x008 = 0x00000000 
set $eeprom_0x00C = 0x34354D50 
set $eeprom_0x010 = 0x44323037 
set $eeprom_0x014 = 0x00003241 
set $eeprom_0x018 = 0x00000000 
set $eeprom_0x01C = 0x35354346 
set $eeprom_0x020 = 0x44333231 
set $eeprom_0x024 = 0x00004431 
set $eeprom_0x028 = 0x00000000 
set $eeprom_0x02C = 0x9C5D1040 
set $eeprom_0x030 = 0x000000C0 
set $eeprom_0x034 = 0x00000000 
set $eeprom_0x038 = 0x00000000 
set $eeprom_0x03C = 0x00000000 
set $eeprom_0x040 = 0x00000000 
set $eeprom_0x044 = 0x00000000 
set $eeprom_0x048 = 0x00000000 
set $eeprom_0x04C = 0x00000000 
set $eeprom_0x050 = 0x00000000 
set $eeprom_0x054 = 0x00000000 
set $eeprom_0x058 = 0x00000000 
set $eeprom_0x05C = 0x00000000 
set $eeprom_0x060 = 0x00000000 
set $eeprom_0x064 = 0x00000000 
set $eeprom_0x068 = 0x00000000 
set $eeprom_0x06C = 0x00000000 
set $eeprom_0x070 = 0x00000000 
set $eeprom_0x074 = 0xFFFF0A00 
set $eeprom_0x078 = 0xFF050903 
set $eeprom_0x07C = 0xFFFFFFFF 
set $eeprom_0x080 = 0xFFFFFFFF 

set $eeprom_0x500 = 0x00000000

#                                                                              #
# End: Simulation Run Configuration Variables.                                 #
#------------------------------------------------------------------------------#


# Set preferred gdb layout
layout reg

# Connect to remote simulator (i.e. pinkySim) being run on port 3333 of local machine
target remote localhost:3333


#------------------------------------------------------------------------------#


# Default register settings according to User Manaul UM10462:

# Default register settings for system control block (base address 0x4004 8000)
set {int}0x40048000 = 0x02
set {int}0x40048028 = 0x080
set {int}0x40048030 = 0x3
set {int}0x40048040 = 0x1
set {int}0x40048044 = 0x1
set {int}0x40048074 = 0x1
set {int}0x40048078 = 0x1
set {int}0x40048080 = 0x3F
# set {int}0x40048100 = User Dependent TODO: need this to be non-zero?
# set {int}0x40048104 = User Dependent TODO: need this to be non-zero?
set {int}0x40048170 = 0x10
set {int}0x4004819C = 0x1
set {int}0x40048230 = 0xFFFF
set {int}0x40048234 = 0xEDF0
set {int}0x40048238 = 0xEDD0
# set {int}0x400483F4 = Part Dependent TODO: need this to be non-zero?

# Default register settings for I/O configuration (base address 0x4004 4000)
set {int}0x40044000 = 0x00000090
set {int}0x40044004 = 0x00000090
set {int}0x40044008 = 0x00000090
set {int}0x4004400C = 0x00000090
set {int}0x40044010 = 0x00000080
set {int}0x40044014 = 0x00000080
set {int}0x40044018 = 0x00000090
set {int}0x4004401C = 0x00000090
set {int}0x40044020 = 0x00000090
set {int}0x40044024 = 0x00000090
set {int}0x40044028 = 0x00000090
set {int}0x4004402C = 0x00000090
set {int}0x40044030 = 0x00000090
set {int}0x40044034 = 0x00000090
set {int}0x40044038 = 0x00000090
set {int}0x4004403C = 0x00000090
set {int}0x40044040 = 0x00000090
set {int}0x40044044 = 0x00000090
set {int}0x40044048 = 0x00000090
set {int}0x4004404C = 0x00000090
set {int}0x40044050 = 0x00000090
set {int}0x40044054 = 0x00000090
set {int}0x40044058 = 0x00000090
set {int}0x4004405C = 0x00000090
set {int}0x40044060 = 0x00000090
set {int}0x40044064 = 0x00000090
set {int}0x40044068 = 0x00000090
set {int}0x4004406C = 0x00000090
set {int}0x40044070 = 0x00000090
set {int}0x40044074 = 0x00000090
set {int}0x40044078 = 0x00000090
set {int}0x4004407C = 0x00000090
set {int}0x40044080 = 0x00000090
set {int}0x40044084 = 0x00000090
set {int}0x40044088 = 0x00000090
set {int}0x4004408C = 0x00000090
set {int}0x40044090 = 0x00000090
set {int}0x40044094 = 0x00000090
set {int}0x40044098 = 0x00000090
set {int}0x4004409C = 0x00000090
set {int}0x400440A0 = 0x00000090
set {int}0x400440A4 = 0x00000090
set {int}0x400440A8 = 0x00000090
set {int}0x400440AC = 0x00000090
set {int}0x400440B0 = 0x00000090
set {int}0x400440B4 = 0x00000090
set {int}0x400440B8 = 0x00000090
set {int}0x400440BC = 0x00000090
set {int}0x400440C0 = 0x00000090
set {int}0x400440C4 = 0x00000090
set {int}0x400440C8 = 0x00000090
set {int}0x400440CC = 0x00000090
set {int}0x400440D0 = 0x00000090
set {int}0x400440D4 = 0x00000090
set {int}0x400440DC = 0x00000090

# Default register settings for GPIO GROUP0 interrupt (base address 0x4005 C000)
set {int}0x4005C020 = 0xFFFFFFFF
set {int}0x4005C024 = 0xFFFFFFFF

# Default register settings for GPIO GROUP1 interrupt (base address 0x4006 0000)
set {int}0x40060020 = 0xFFFFFFFF
set {int}0x40060024 = 0xFFFFFFFF

# Default register settings for GPIO port (base address 0x5000 0000)
# set {char}0x50000000 = pin state TODO: Should this be non-zero?
# set {char}0x50000001 = pin state TODO: Should this be non-zero?

# PIO0_2 is read during init. Interrupt setup to monitor state change.
set {char}0x50000002 = 0

# PIO0_3 is USB_VBUS and indiciates if there USB bus power. If 1 system will
#  boot and wait for USB enumeration/probing. If 0 system will boot and wait
#  for data from RF chip.
set {char}0x50000003 = 1

# set {char}0x50000004 = pin state TODO: Should this be non-zero?
# set {char}0x50000005 = pin state TODO: Should this be non-zero?
# set {char}0x50000006 = pin state TODO: Should this be non-zero?
# set {char}0x50000007 = pin state TODO: Should this be non-zero?
# set {char}0x50000008 = pin state TODO: Should this be non-zero?
# set {char}0x50000009 = pin state TODO: Should this be non-zero?
# set {char}0x5000000A = pin state TODO: Should this be non-zero?
# set {char}0x5000000B = pin state TODO: Should this be non-zero?
# set {char}0x5000000C = pin state TODO: Should this be non-zero?
# set {char}0x5000000D = pin state TODO: Should this be non-zero?
# set {char}0x5000000E = pin state TODO: Should this be non-zero?
# set {char}0x5000000F = pin state TODO: Should this be non-zero?
# set {char}0x50000010 = pin state TODO: Should this be non-zero?
# set {char}0x50000011 = pin state TODO: Should this be non-zero?

# PIO0_18 is read if PIO1_12 is low. RAM address 0x100002b3 set based on value.
set {char}0x50000012 = 1

# set {char}0x50000013 = pin state TODO: Should this be non-zero?
# set {char}0x50000014 = pin state TODO: Should this be non-zero?
# set {char}0x50000015 = pin state TODO: Should this be non-zero?
# set {char}0x50000016 = pin state TODO: Should this be non-zero?
# set {char}0x50000017 = pin state TODO: Should this be non-zero?
# set {char}0x50000018 = pin state TODO: Should this be non-zero?
# set {char}0x50000020 = pin state TODO: Should this be non-zero?
# set {char}0x50000021 = pin state TODO: Should this be non-zero?
# set {char}0x50000022 = pin state TODO: Should this be non-zero?
# set {char}0x50000023 = pin state TODO: Should this be non-zero?
# set {char}0x50000024 = pin state TODO: Should this be non-zero?
# set {char}0x50000025 = pin state TODO: Should this be non-zero?
# set {char}0x50000026 = pin state TODO: Should this be non-zero?
# set {char}0x50000027 = pin state TODO: Should this be non-zero?
# set {char}0x50000028 = pin state TODO: Should this be non-zero?
# set {char}0x50000029 = pin state TODO: Should this be non-zero?
# set {char}0x5000002A = pin state TODO: Should this be non-zero?
# set {char}0x5000002B = pin state TODO: Should this be non-zero?

# PIO1_12 is connected to VDD for Haptics. RAM address 0x100002b3 set based on value.
set {char}0x5000002C = 1

# set {char}0x5000002D = pin state TODO: Should this be non-zero?
# set {char}0x5000002E = pin state TODO: Should this be non-zero?
# set {char}0x5000002F = pin state TODO: Should this be non-zero?
# set {char}0x5000002F = pin state TODO: Should this be non-zero?
# set {int}0x50001000 = pin state TODO: Should this be non-zero?
# set {int}0x50001004 = pin state TODO: Should this be non-zero?
# set {int}0x50001008 = pin state TODO: Should this be non-zero?
# set {int}0x5000100C = pin state TODO: Should this be non-zero?
# set {int}0x50001010 = pin state TODO: Should this be non-zero?
# set {int}0x50001014 = pin state TODO: Should this be non-zero?
# set {int}0x50001018 = pin state TODO: Should this be non-zero?
# set {int}0x5000101C = pin state TODO: Should this be non-zero?
# set {int}0x50001020 = pin state TODO: Should this be non-zero?
# set {int}0x50001024 = pin state TODO: Should this be non-zero?
# set {int}0x50001028 = pin state TODO: Should this be non-zero?
# set {int}0x5000102C = pin state TODO: Should this be non-zero?
# set {int}0x50001030 = pin state TODO: Should this be non-zero?
# set {int}0x50001034 = pin state TODO: Should this be non-zero?
# set {int}0x50001038 = pin state TODO: Should this be non-zero?
# set {int}0x5000103C = pin state TODO: Should this be non-zero?
# set {int}0x50001040 = pin state TODO: Should this be non-zero?
# set {int}0x50001044 = pin state TODO: Should this be non-zero?
# set {int}0x50001048 = pin state TODO: Should this be non-zero?
# set {int}0x5000104C = pin state TODO: Should this be non-zero?
# set {int}0x50001050 = pin state TODO: Should this be non-zero?
# set {int}0x50001054 = pin state TODO: Should this be non-zero?
# set {int}0x50001058 = pin state TODO: Should this be non-zero?
# set {int}0x5000105C = pin state TODO: Should this be non-zero?
# set {int}0x50001060 = pin state TODO: Should this be non-zero?
# set {int}0x50001080 = pin state TODO: Should this be non-zero?
# set {int}0x50001084 = pin state TODO: Should this be non-zero?
# set {int}0x50001088 = pin state TODO: Should this be non-zero?
# set {int}0x5000108C = pin state TODO: Should this be non-zero?
# set {int}0x50001090 = pin state TODO: Should this be non-zero?
# set {int}0x50001094 = pin state TODO: Should this be non-zero?
# set {int}0x50001098 = pin state TODO: Should this be non-zero?
# set {int}0x5000109C = pin state TODO: Should this be non-zero?
# set {int}0x500010A0 = pin state TODO: Should this be non-zero?
# set {int}0x500010A4 = pin state TODO: Should this be non-zero?
# set {int}0x500010A8 = pin state TODO: Should this be non-zero?
# set {int}0x500010AC = pin state TODO: Should this be non-zero?
# set {int}0x500010B0 = pin state TODO: Should this be non-zero?
# set {int}0x500010B4 = pin state TODO: Should this be non-zero?
# set {int}0x500010B8 = pin state TODO: Should this be non-zero?
# set {int}0x500010BC = pin state TODO: Should this be non-zero?
# set {int}0x500010C0 = pin state TODO: Should this be non-zero?
# set {int}0x500010C4 = pin state TODO: Should this be non-zero?
# set {int}0x500010C8 = pin state TODO: Should this be non-zero?
# set {int}0x500010CC = pin state TODO: Should this be non-zero?
# set {int}0x500010D0 = pin state TODO: Should this be non-zero?
# set {int}0x500010D4 = pin state TODO: Should this be non-zero?
# set {int}0x500010D8 = pin state TODO: Should this be non-zero?
# set {int}0x500010DC = pin state TODO: Should this be non-zero?
# set {int}0x500010E0 = pin state TODO: Should this be non-zero?
# set {int}0x500010E4 = pin state TODO: Should this be non-zero?
# set {int}0x500010E8 = pin state TODO: Should this be non-zero?
# set {int}0x500010EC = pin state TODO: Should this be non-zero?
# set {int}0x500010F0 = pin state TODO: Should this be non-zero?
# set {int}0x500010F4 = pin state TODO: Should this be non-zero?
# set {int}0x500010F8 = pin state TODO: Should this be non-zero?
# set {int}0x500010FC = pin state TODO: Should this be non-zero?
# set {int}0x50002100 = pin state TODO: Should this be non-zero?
# set {int}0x50002104 = pin state TODO: Should this be non-zero?
# set {int}0x50002180 = pin state TODO: Should this be non-zero?
# set {int}0x50002184 = pin state TODO: Should this be non-zero?

# Default register settings for USB (base address: 0x4008 0000)
set {int}0x40080000 = 0x00000800

# Default register settings for USART (base address: 0x4000 8000)
# set {int}0x40008000 = TODO: reset value is 0x1 if DLAB=1
set {int}0x40008008 = 0x01
set {int}0x40008014 = 0x60
set {int}0x40008028 = 0x10
set {int}0x4000802C = 0xF0
set {int}0x40008030 = 0x80

# Default register settings for SSP/SPI0 (base address 0x4004 0000)
set {int}0x4004000C = 0x00000003
set {int}0x40040018 = 0x00000008

# Default register settings for SSP/SPI1 (base address 0x4005 8000)
set {int}0x4005800C = 0x00000003
set {int}0x40058018 = 0x00000008

# Default register settings for I2C (base address 0x4000 0000)
set {int}0x40000000 = 0x00
set {int}0x40000004 = 0xF8
set {int}0x40000010 = 0x04
set {int}0x40000014 = 0x04

# Default register settings for Watchdog timer (base address 0x4000 4000)
set {int}0x40004004 = 0xFF
set {int}0x4000400C = 0xFF
set {int}0x40004018 = 0xFFFFFF

# Default register settings for SysTick timer (base address 0xE000 E000)
set {int}0xE000E01C = 0x4

# Default register settings for ADC (base address 0x4001 C000)
set {int}0x4001C00C = 0x00000100


#------------------------------------------------------------------------------#


# Non-default register settings required for simulation to progress:

# Flash/EEPROM Controller Non-Default Register Settings (base offset 0x4003C000):

# Set Flash configuration register 0x4003c010 to 0x00000002 (reset value)
set {int}0x4003c010 = 2
# Set Flash module status register 0x4003cfe0 to 0xFFFFFFFF to indicate that EEPROM write finished
#  Note: According to UM10462 datahsset, flash module status register 0x4003cfe0 only has bit 2 as 
#  non-reserved, but boot ROM code is checking other bits for status.Assumptionis that this must be 
#  some weird hardware issue with how reserved bits function. Upper bits should be non-use, but 
#  setting bit 2 does not add up to check being performed on register (lsl immediate).
set {int}0x4003cfe0 = 0xFFFFFFFF


# System Control Non-Default Register Settings (base offset 0x40048000):

# Set System PLL status register 0x4004800c to 0x00000001 (indicates System PLL is locked)
set {int}0x4004800c = 1 
# Set USB PLL status register 0x40048014 to 0x00000001 (indicates USB PLL is locked)
set {int}0x40048014 = 1


#------------------------------------------------------------------------------#


# Fill boot ROM with binary downloaded from LPC11U37
restore LPC11U3x16kBbootROM.bin binary 0x1fff0000


#------------------------------------------------------------------------------#


# Setup watchpoint for instruction immediately before checking values first
#  read from EEPROM (i.e. magic number and hw version)
watch $pc == 0x00000d10

# Execute until watchpoint
continue

# Fill in memory with what should have been read from EEPROM address offset 0
set {int}0x10000254 = $eeprom_0x000
set {int}0x10000258 = $eeprom_0x004

# Remove watchpoint
delete 


#------------------------------------------------------------------------------#


# Setup watchpoint for instruction immediately before checking values first
#  read from EEPROM offset 0x500 (TODO: purpose of this data?)
watch $pc == 0x000015be

# Execute until watchpoint
continue

# Fill in memory with what should have been read from EEPROM address offset 0
set {int}0x10001c08 = $eeprom_0x500

# Remove watchpoint
delete 


#------------------------------------------------------------------------------#


# Setup watchpoint for instruction immediately after reading 0x84 bytes from
#  offset 0x0 of EEPROM, after basic init and power up
watch $pc == 0x00005d28

# Execute until watchpoint
continue

# Fill in memory with what should have been read from EEPROM address offset 0
set {int}0x100009b4 = $eeprom_0x000
set {int}0x100009b8 = $eeprom_0x004
set {int}0x100009bc = $eeprom_0x008
set {int}0x100009c0 = $eeprom_0x00C
set {int}0x100009c4 = $eeprom_0x010
set {int}0x100009c8 = $eeprom_0x014
set {int}0x100009cc = $eeprom_0x018
set {int}0x100009d0 = $eeprom_0x01C
set {int}0x100009d4 = $eeprom_0x020
set {int}0x100009d8 = $eeprom_0x024
set {int}0x100009dc = $eeprom_0x028
set {int}0x100009e0 = $eeprom_0x02C
set {int}0x100009e4 = $eeprom_0x030
set {int}0x100009e8 = $eeprom_0x034
set {int}0x100009ec = $eeprom_0x038
set {int}0x100009f0 = $eeprom_0x03C
set {int}0x100009f4 = $eeprom_0x040
set {int}0x100009f8 = $eeprom_0x044
set {int}0x100009fc = $eeprom_0x048
set {int}0x10000a00 = $eeprom_0x04C
set {int}0x10000a04 = $eeprom_0x050
set {int}0x10000a08 = $eeprom_0x054
set {int}0x10000a0c = $eeprom_0x058
set {int}0x10000a10 = $eeprom_0x05C
set {int}0x10000a14 = $eeprom_0x060
set {int}0x10000a18 = $eeprom_0x064
set {int}0x10000a1c = $eeprom_0x068
set {int}0x10000a20 = $eeprom_0x06C
set {int}0x10000a24 = $eeprom_0x070
set {int}0x10000a28 = $eeprom_0x074
set {int}0x10000a2c = $eeprom_0x078
set {int}0x10000a30 = $eeprom_0x07C
set {int}0x10000a34 = $eeprom_0x080

# Remove watchpoint
delete 


#------------------------------------------------------------------------------#


# Set watch point for 16-bit Timer 1 (CT16B1) Timer Counter register
#  In path for controller not connected to USB cable, CT16B1 is used as PWM
#   for Steam Controller Button LED.
watch *(int*)0x40010008

# Execute until watchpoint
continue

# Assumption is we have broken for watch on CT16B1 Timer Counter register
#  Set back to zero to fake wrap around so code can continue
set {int}0x40010008 = 0

# Remove watchpoint
delete 


#------------------------------------------------------------------------------#


# Events change based on whether USB cable is connected (volatage present) or not
if *(char*)0x50000003 == 0

	# NOTE: We need to spend more time on this path. Somehow this "should"
	#  lead to communicating with the RF chip, but I have not figured that out yet...

	#------------------------------------------------------------------------------#


	# Setup watchpoint for wfi instruction.
	watch $pc ==  0x00002cfe
	
	# Execute until watchpoint
	continue
	
	# Simulate interrupt(s) (either for C conversion, or to carry on sim as though 
	#  fired and was handled properly).
	
	##
	# PIN_INT1 (Setup for state change on PIO0_2) Execution:
	# NOTE: This is DESTRUCTIVE of processor state. Use only to obtain simulation of 
	#  interrupt. Vector Table entry is 0x00000129.
	##set $lr = $pc
	##set $pc = 0x00000128
	#TODO: Might want to try making not destructive (if need to simulate it or other
	#  interrupts in the future). See Fig 81 in UM10462 for what to save to stack, 
	#  and update LR. Then when we get back to PC of wfi we manually pop off stack. 
	##
	
	##
	# ADC Interrupt Execution:
	# NOTE: This is DESTRUCTIVE of processor state. Use only to obtain simulation of 
	#  interrupt. Vector Table entry is 0x00000205.
	##set $lr = $pc
	##set $pc = 0x00000204
	# Counter for how many times interrupt fires initially
	##set {int}0x10000014 = 0x0000012d
	# Counter for how many times interrupt fires for accumulating ADC values
	##set {int}0x10000018 = 0x00000007
	#TODO: Might want to try making not destructive (if need to simulate it or other
	#  interrupts in the future). See Fig 81 in UM10462 for what to save to stack, 
	#  and update LR. Then when we get back to PC of wfi we manually pop off stack. 
	## 
	
	##
	# Change states as though ADC interrupt ran as desired:
	# Set PC to move past wfi (as simulator cannot handle it)
	set $pc = 0x00002d00
	# Set ADC counter variables (should not really be needed once ISR has served its 
	#  purpose. But setting to final values just to be safe and accurate).
	set {int}0x10000014 = 0x0000012d
	set {int}0x10000018 = 0x00000007
	# Set flag to indciate ADC ISR has served its purpose and ADC is shutdown
	set {char}0x10000010 = 1
	# Set value of counter used to accumulate ADC values
	# TODO: Need to figure out what this value should be and how that affects sim...
	set {short}0x10000f8c = 0
	## 
	
	# Remove watchpoint
	delete 

#TODO: whats next? What causes system to interact with RF chip (and via what interface? USART?)?


	#------------------------------------------------------------------------------#


	# Resume execution (execution will break on wfi that pinkySim cannot handle)
	#
	# This ends in infinite wfi loop (presumably waiting for system to power down
	#  because something is wrong with power supples, or brown out?)
	continue


	#------------------------------------------------------------------------------#



else


	#------------------------------------------------------------------------------#


	# Set watch point for 16-bit Timer 0 (CT16B0) Timer Counter register
	#  In path for controller not connected to USB cable, CT16B0 is used for ... TODO
	watch *(int*)0x4000c008

	# Execute until watchpoint
	continue

	# Assumption is we have broken for watch on CT16B1 Timer Counter register
	#  Set back to zero to fake wrap around so code can continue
	set {int}0x4000c008 = 0

	# Remove watchpoint
	delete 


	#------------------------------------------------------------------------------#


	# Setup watchpoint for wfi instruction.
	watch $pc == 0x000051aa
	
	# Execute until watchpoint
	continue
	
	# Simulate interrupt(s) (either for C conversion, or to carry on sim as though 
	#  fired and was handled properly).
	
	##
	# CT16B0: An interrupt is generated when MR0 matches the value in the TC.
	# NOTE: This is DESTRUCTIVE of processor state. Use only to obtain simulation of 
	#  interrupt. Vector Table entry is 0x00000129.
	##set $lr = $pc
	##set $pc = 0x000001a0
	# Set Interrupt Register to indicate Interrupt flag for match channel 0
	##set {int}0x4000c000 = 1
	# TODO: Try adding watch for clearing IR once it's written? Or are we confident we have ISR mapped?
	#TODO: Might want to try making not destructive (if need to simulate it or other
	#  interrupts in the future). See Fig 81 in UM10462 for what to save to stack, 
	#  and update LR. Then when we get back to PC of wfi we manually pop off stack. 
	##
	
	##
	# Change states as though CT16B0 interrupt ran as desired:
	# Set PC to move past wfi (as simulator cannot handle it)
	set $pc = 0x000051ac
	# Set flag to indicate that ISR for CT16B0 has fired
	set {char}0x10000001 = 1
	##
	
	# Remove watchpoint
	delete 


	#------------------------------------------------------------------------------#


	# Handle SPI responses for Shutdown/Standby Command for Right Haptic

	# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
	watch $pc == 0x00008f34
	
	# Execute until watchpoint
	continue

	# Write SPI response data and mark FIFO as not empty
	set {int}0x4004000C = 0x00000007
	#  Fill byte for 0x83 write command
	set {int}0x40040008 = 0x000000FB

	# Make sure we move past this instruction before next watch
	stepi

	# Remove watchpoint
	delete 


	# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
	watch $pc == 0x00008f34
	
	# Execute until watchpoint
	continue

	# Write SPI response data and mark FIFO as not empty
	set {int}0x4004000C = 0x00000007
	#  Fill byte for 0x02 register specification following write command 
	set {int}0x40040008 = 0x000000FB

	# Make sure we move past this instruction before next watch
	stepi

	# Remove watchpoint
	delete 


	# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
	watch $pc == 0x00008f34
	
	# Execute until watchpoint
	continue

	# Write SPI mark FIFO as empty so code stops reading it (and does not overflow...)
	set {int}0x4004000C = 0x00000003

	# Make sure we move past this instruction before next watch
	stepi

	# Remove watchpoint
	delete 


	#------------------------------------------------------------------------------#

	
	# Handle SPI responses for Shutdown/Standby Command for Left Haptic

	# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
	watch $pc == 0x00008f34
	
	# Execute until watchpoint
	continue

	# Write SPI response data and mark FIFO as not empty
	set {int}0x4004000C = 0x00000007
	#  Fill byte for 0x83 write command
	set {int}0x40040008 = 0x000000FB

	# Make sure we move past this instruction before next watch
	stepi

	# Remove watchpoint
	delete 


	# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
	watch $pc == 0x00008f34
	
	# Execute until watchpoint
	continue

	# Write SPI response data and mark FIFO as not empty
	set {int}0x4004000C = 0x00000007
	#  Fill byte for 0x02 register specification following write command 
	set {int}0x40040008 = 0x000000FB

	# Make sure we move past this instruction before next watch
	stepi

	# Remove watchpoint
	delete 


	# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
	watch $pc == 0x00008f34
	
	# Execute until watchpoint
	continue

	# Write SPI mark FIFO as empty so code stops reading it (and does not overflow...)
	set {int}0x4004000C = 0x00000003

	# Make sure we move past this instruction before next watch
	stepi

	# Remove watchpoint
	delete 


	#------------------------------------------------------------------------------#


	# Setup watchpoint for busy wait on checking value of I2C_XFER_T.status (0x10000d94)
	watch $pc == 0x0000425c

	# Execute until watchpoint
	continue

	##
	# NOTE: We don't need to simulate I2C interrupt as we can abstract 
	#  communications at higher level since lpc_chip_11uxx_lib is being used
	#  for I2C comms. Leaving this here for history's sake.
	#
	# I2C: (IRQ15) An interrupt is generated by I2C controller when the I2C
	#  state changes.
	# NOTE: This is DESTRUCTIVE of processor state. Use only to obtain simulation of 
	#  interrupt. Vector Table entry is 0x00000199.
	##set $lr = $pc
	##set $pc = 0x00000198
	# Set I2C STAT code: A START condition has been transmitted.
	##set {int}0x40000004 = 0x08
	##

	# Set I2C_XFER_T.status to I2C_STATUS_DONE (to indicate successful transfer)
	set {int}0x10000d94 = 0

	# Remove watchpoint
	delete 


	#------------------------------------------------------------------------------#


# Simulate USB Callbacks...

	# Setup watchpoint for...
#	watch $pc == 0x000098f0

	# Execute until watchpoint
#	continue

#	stepi

	##
	##set $lr = $pc
	# arg0 = hUsb
	##set $r0 = 0x20004118
	# USB_Configure_Event
	##set $pc = 0x00004e58

	##set $lr = $pc
	# arg0 = hUsb
	##set $r0 = 0x20004118
	# USB_Reset_Event
	##set $pc = 0x00008d8a

#	set $lr = $pc
	# arg0 = hUsb
#	set $r0 = 0x20004118
	# USB_Reset_Event
#	set $pc = 0x00008de4
	##

	# Remove watchpoint
#	delete 


	#------------------------------------------------------------------------------#

# TODO: try simulating past wfi for ADC read... Does this lead anywhere positive?

	# Setup watchpoint 
	watch $pc == 0x00002d00

	# Execute until watchpoint
	continue

	# Set ADC counter variables (should not really be needed once ISR has served its 
	#  purpose. But setting to final values just to be safe and accurate).
	set {int}0x10000014 = 0x0000012d
	set {int}0x10000018 = 0x00000007
	# Set flag to indciate ADC ISR has served its purpose and ADC is shutdown
	set {char}0x10000010 = 1
	# Set value of counter used to accumulate ADC values
# TODO: Need to figure out what this value should be and how that affects sim...
	set {short}0x10000f8c = 0

	# Remove watchpoint
	delete 

	#------------------------------------------------------------------------------#


	# Resume execution until...?
	continue


	#------------------------------------------------------------------------------#


end
