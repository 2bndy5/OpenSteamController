###############################################################################
# Command file that contains user-defined commands for helping simulate
#	Steam Controller Firmware. There are a number of instances where the
#	firmware interacts with peripherals and appropriate behavior needs to
#	be added for the simulation to continue. These functions help to
#	encapsulate these behaviors as they may need to be called multiple
#	times and under different circumstances.
#
# Execute in gdb using "source" command.
#  For details refer to: https://sourceware.org/gdb/onlinedocs/gdb/Command-Files.html
# Note: This needs to be sourced before any script that might use these commands.
#	
# Note: These functions may be specific to simulations for firmware version 
#	vcf_wired_controller_d0g_57bf5c10.bin.
#
# Execute in gdb using "source" command.
#  For details refer to: https://sourceware.org/gdb/onlinedocs/gdb/Command-Files.html
#
# Note this was developed by simulating vcf_wired_controller_d0g_57bf5c10.bin,
#  and may not work properly with other firmware.
#
#  MIT License
# 
#  Copyright (c) 2018 Gregory Gluszek
# 
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
# 
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
# 
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
###############################################################################

## 
# Calling commands below will clear all watchpoints (i.e. that are set to  
#	trigger at beginning of functions that need simulation assistance). 
#	This command makes sure the watchpoints get reset and execution 
#	continues until a watchpoint occurs.
define reset_top_level_watchpoints
	# Entry point of CT16B0 Sleep Function fnc0x00005174()
	watch $pc == 0x00005174

	# Entry point of Trackpad ASIC Register Write Function fnc0x00004c7e()
	watch $pc == 0x00004c7e

	# Entry point of Trackpad ASIC Register Read Function fnc0x0000491c()
	watch $pc == 0x0000491c

	continue
end

##
# This command handles simulating through CT16B0 Sleep Function fnc0x00005174().
#	This function configures CT16B0 and then waits for an the CT16B0 IRQ
#	to fire (which changes a global variable).
define check_ct16b0_sleep

	# Check if we stopped at entry to CT16B0 Sleep Function fnc0x00005174()
	if $pc == 0x00005174

		echo \n
		echo DETECTED fnc0x00005174(): sleep via CT16B0 IRQ. \n
		echo \n

		# Remove all watchpoints
		delete


		# Set watch point for 16-bit Timer 0 (CT16B0) Timer Counter register
		watch *(int*)0x4000c008

		echo Waiting for CT16B0 TC to be set to simulate wrap around \n

		# Execute until watchpoint
		continue

		# Set back to zero to simulate wrap around so code can continue
		set {int}0x4000c008 = 0

		# Remove all watchpoint
		delete 


		# Setup watchpoint for wfi instruction.
		watch $pc == 0x000051aa

		echo Waiting for wfi related to CT16B0 IRQ \n
		
		# Execute until watchpoint
		continue
		
		# Change states as though CT16B0 interrupt ran as desired:
		# Set PC to move past wfi (as simulator cannot handle it)
		set $pc = 0x000051ac
		# Set flag to indicate that ISR for CT16B0 has fired
		set {char}0x10000001 = 1
		
		# Remove all watchpoints
		delete 

		echo \n
		echo HANDLED fnc0x00005174(): sleep via CT16B0 IRQ. \n
		echo \n

	end
end


##
# This command handles simulating through Trackpad ASIC Register Write Function 
#	fnc0x00004c7e(). This function writes two SPI bytes to the SPI MOSI FIFO
#	and then expects a response of exactly two bytes from the SPI MISO FIFO.
define check_trackpad_asic_reg_write

	# Check if we stopped at entry to Trackpad ASIC Register Write Function fnc0x00004c7e()
	if $pc == 0x00004c7e

		echo \n
		echo DETECTED fnc0x00004c7e(): Trackpad ASIC Reg Write. \n
		echo \n

		# Remove all watchpoints
		delete


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 1 of Reg Write command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark SPI MISO FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte (or could be response to previous command technically)
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 2 of Reg Write command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark SPI MISO FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove watchpoint
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to change SPI MISO FIFO status after 2 response bytes for Reg Write command \n
		
		# Execute until watchpoint
		continue

		# Mark SPI MISO FIFO as empty so code stops reading it (and does not overflow...)
		set {int}0x4004000C = 0x00000003

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		echo \n
		echo HANDLED fnc0x00004c7e(): Trackpad ASIC Reg Write. \n
		echo \n
	end
end



##
# This command handles simulating through Trackpad ASIC Register Read Function 
#	fnc0x0000491c(). This function writes four SPI bytes to the SPI MOSI FIFO
#	and then expects a response of exactly four bytes from the SPI MISO FIFO, 
#	with the fourth byte being the value "read" from the register specified
#	in the byte 1 write.
define check_trackpad_asic_reg_read

	# Check if we stopped at entry to Trackpad ASIC Register Read Function fnc0x0000491c()
	if $pc == 0x0000491c

		echo \n
		echo DETECTED fnc0x0000491c(): Trackpad ASIC Reg Read. \n
		echo \n

		# Extract ASIC register read address
		set $asic_rd_addr = $r1

		# Set default value for ASIC register read value
		set $asic_rd_val = 0

		if ($asic_rd_addr == 0x00)
			echo Reading ASIC Firmware ID Register \n
			set $asic_rd_val = 0x07
		end
		if ($asic_rd_addr == 0x01)
			echo Reading ASIC Firmware Version Register \n
			set $asic_rd_val = 0x3a
		end
		if ($asic_rd_addr == 0x02)
			echo Reading ASIC Status1 Register \n
			set $asic_rd_val = 0x08
		end
		if ($asic_rd_addr == 0x03)
			echo Reading ASIC SysConfig1 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x04)
			echo Reading ASIC FeedConfig1 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x05)
			echo Reading ASIC FeedConfig2 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x06)
			echo Reading ASIC FeedConfig3 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x07)
			echo Reading ASIC CalConfig1 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x08)
			echo Reading ASIC PS/2 Aux Control Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x09)
			echo Reading ASIC Sample Rate Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0a)
			echo Reading ASIC ZIdle Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0b)
			echo Reading ASIC Z Scaler Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0c)
			echo Reading ASIC Sleep Interval Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0d)
			echo Reading ASIC Sleep Timer Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0e)
			echo Reading ASIC Dynamic EMI Adjust Threshold Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0f)
			echo Reading ASIC 0x0f RESERVED Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x10)
			echo Reading ASIC 0x10 RESERVED Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x11)
			echo Reading ASIC 0x11 RESERVED Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x12)
			echo Reading ASIC PacketByte_0 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x13)
			echo Reading ASIC PacketByte_1 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x14)
			echo Reading ASIC PacketByte_2 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x15)
			echo Reading ASIC PacketByte_3 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x16)
			echo Reading ASIC PacketByte_4 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x17)
			echo Reading ASIC PacketByte_5 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x18)
			echo Reading ASIC Port A GPIO Control Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x19)
			echo Reading ASIC Port A GPIO Data Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1a)
			echo Reading ASIC Port B GPIO Control and Data Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1b)
			echo Reading ASIC ERA Value Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1c)
			echo Reading ASIC ERA Address High Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1d)
			echo Reading ASIC ERA Address Low Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1e)
			echo Reading ASIC ERA Address Control Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1f)
			echo Reading ASIC Product ID Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end

		
		# Remove all watchpoints
		delete


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 1 of Reg Read command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 1 (or could technically be response to previous command)
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 2 of Reg Read command \n
	
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 2
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 3 of Reg Read command \n
	
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 3
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 4 of Reg Read command \n
	
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		# Value "read" from ASIC register 
		set {int}0x40040008 = $asic_rd_val

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# SPI transaction complete
		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to change SPI MISO FIFO status after 4 response bytes for Reg Read command \n
	
		# Execute until watchpoint
		continue

		# Write SPI mark FIFO as empty so code stops reading it (and does not overflow...)
		set {int}0x4004000C = 0x00000003

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		echo \n
		echo HANDLED fnc0x0000491c(): Trackpad ASIC Reg Read. \n
		echo \n
	end
end

##
#TODO: fnc0x00004c14()
# define check_trackpad_asic_era_write_multiple

## 
#TODO: fnc0x0000573c()
# define check_trackpad_asic_reg_read_autoinc
