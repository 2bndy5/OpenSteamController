###############################################################################
# Command file that contains user-defined commands for helping simulate
#	Steam Controller Firmware. There are a number of instances where the
#	firmware interacts with peripherals and appropriate behavior needs to
#	be added for the simulation to continue. These functions help to
#	encapsulate these behaviors as they may need to be called multiple
#	times and under different circumstances.
#
# Execute in gdb using "source" command.
#  For details refer to: https://sourceware.org/gdb/onlinedocs/gdb/Command-Files.html
# Note: This needs to be sourced before any script that might use these commands.
#	
# Note: These functions may be specific to simulations for firmware version 
#	vcf_wired_controller_d0g_57bf5c10.bin.
#
# Execute in gdb using "source" command.
#  For details refer to: https://sourceware.org/gdb/onlinedocs/gdb/Command-Files.html
#
# Note this was developed by simulating vcf_wired_controller_d0g_57bf5c10.bin,
#  and may not work properly with other firmware.
#
#  MIT License
# 
#  Copyright (c) 2018 Gregory Gluszek
# 
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
# 
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
# 
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
###############################################################################

## 
# Calling commands below will clear all watchpoints (i.e. that are set to  
#	trigger at beginning of functions that need simulation assistance). 
#	This command makes sure the watchpoints get reset and execution 
#	continues until a watchpoint occurs.
define reset_top_level_watchpoints

	# Variable to control simulation of IRQs
	#  Note each of these simulations are destructive and if true (1) they 
	#   will simulate ISR and then simulation will either stop or report
	#   repeated Hard Faults.
	#  This is intended to figure out what ISRs are doing
	set $irq_sim_pint3 = 0
	set $irq_sim_ct32b0 = 0 


	echo Entry point of CT16B0 Sleep Function fnc0x00005174() \n
	watch $pc == 0x00005174

	echo Entry point of Trackpad ASIC Register Write Function fnc0x00004c7e() \n
	watch $pc == 0x00004c7e

	echo Entry point of Trackpad ASIC Register Read Function fnc0x0000491c() \n
	watch $pc == 0x0000491c

	echo Entry point of Trackpad ASIC Extenda Register Access (ERA) Write Auto Increment Function fnc0x00004c14() \n
	watch $pc == 0x00004c14

	echo Entry point of Trackpad ASIC Data Ready Interrupt Function fnc0x0000b97c() \n
	watch $pc == 0x0000b97c

	echo Entry point of function(s) for reading EEPROM data \n
	watch $pc == 0x00000bdc
	watch $pc == 0x000051c4

	echo Entry point of fnc0x0000573c(): Read SPI ASIC Reg 0x11 and 0x12
	watch $pc == 0x0000573c

	if $irq_sim_pint3
		echo Entry point fnc0x000055e8(): Setup PINT3 (destructive) \n
		watch $pc == 0x000055e8
	end

	if $irq_sim_ct32b0
		echo Return from fnc0x00007a10(): CT32B0 Interrupt Simulation (destructive) \n
		watch $pc == 0x00007a38
	end

	continue
end

##
# This command handles simulating through CT16B0 Sleep Function fnc0x00005174().
#	This function configures CT16B0 and then waits for an the CT16B0 IRQ
#	to fire (which changes a global variable).
define check_ct16b0_sleep

	# Check if we stopped at entry to CT16B0 Sleep Function fnc0x00005174()
	if $pc == 0x00005174

		echo \n
		echo DETECTED fnc0x00005174(): sleep via CT16B0 IRQ. \n
		echo \n

		# Remove all watchpoints
		delete


		# Set watch point for 16-bit Timer 0 (CT16B0) Timer Counter register
		watch *(int*)0x4000c008

		echo Waiting for CT16B0 TC to be set to simulate wrap around \n

		# Execute until watchpoint
		continue

		# Set back to zero to simulate wrap around so code can continue
		set {int}0x4000c008 = 0

		# Remove all watchpoint
		delete 


		# Setup watchpoint for wfi instruction.
		watch $pc == 0x000051aa

		echo Waiting for wfi related to CT16B0 IRQ \n
		
		# Execute until watchpoint
		continue
		
		# Change states as though CT16B0 interrupt ran as desired:
		# Set PC to move past wfi (as simulator cannot handle it)
		set $pc = 0x000051ac
		# Set flag to indicate that ISR for CT16B0 has fired
		set {char}0x10000001 = 1
		
		# Remove all watchpoints
		delete 

		echo \n
		echo HANDLED fnc0x00005174(): sleep via CT16B0 IRQ. \n
		echo \n

	end
end


##
# This command handles simulating through Trackpad ASIC Register Write Function 
#	fnc0x00004c7e(). This function writes two SPI bytes to the SPI MOSI FIFO
#	and then expects a response of exactly two bytes from the SPI MISO FIFO.
define check_trackpad_asic_reg_write

	# Check if we stopped at entry to Trackpad ASIC Register Write Function fnc0x00004c7e()
	if $pc == 0x00004c7e

		echo \n
		echo DETECTED fnc0x00004c7e(): Trackpad ASIC Reg Write. \n
		echo \n

		# Remove all watchpoints
		delete


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 1 of Reg Write command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark SPI MISO FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte (or could be response to previous command technically)
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 2 of Reg Write command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark SPI MISO FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove watchpoint
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to change SPI MISO FIFO status after 2 response bytes for Reg Write command \n
		
		# Execute until watchpoint
		continue

		# Mark SPI MISO FIFO as empty so code stops reading it (and does not overflow...)
		set {int}0x4004000C = 0x00000003

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		echo \n
		echo HANDLED fnc0x00004c7e(): Trackpad ASIC Reg Write. \n
		echo \n
	end
end


##
# This command handles simulating through Trackpad ASIC Register Read Function 
#	fnc0x0000491c(). This function writes four SPI bytes to the SPI MOSI FIFO
#	and then expects a response of exactly four bytes from the SPI MISO FIFO, 
#	with the fourth byte being the value "read" from the register specified
#	in the byte 1 write.
define check_trackpad_asic_reg_read

	# Check if we stopped at entry to Trackpad ASIC Register Read Function fnc0x0000491c()
	if $pc == 0x0000491c

		echo \n
		echo DETECTED fnc0x0000491c(): Trackpad ASIC Reg Read. \n
		echo \n

		# Extract ASIC register read address
		set $asic_rd_addr = $r1

		# Set default value for ASIC register read value
		set $asic_rd_val = 0

		if ($asic_rd_addr == 0x00)
			echo Reading ASIC Firmware ID Register \n
			set $asic_rd_val = 0x07
		end
		if ($asic_rd_addr == 0x01)
			echo Reading ASIC Firmware Version Register \n
			set $asic_rd_val = 0x3a
		end
		if ($asic_rd_addr == 0x02)
			echo Reading ASIC Status1 Register \n
			set $asic_rd_val = 0x08
		end
		if ($asic_rd_addr == 0x03)
			echo Reading ASIC SysConfig1 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x04)
			echo Reading ASIC FeedConfig1 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x05)
			echo Reading ASIC FeedConfig2 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x06)
			echo Reading ASIC FeedConfig3 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x07)
			echo Reading ASIC CalConfig1 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x08)
			echo Reading ASIC PS/2 Aux Control Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x09)
			echo Reading ASIC Sample Rate Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0a)
			echo Reading ASIC ZIdle Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0b)
			echo Reading ASIC Z Scaler Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0c)
			echo Reading ASIC Sleep Interval Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0d)
			echo Reading ASIC Sleep Timer Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0e)
			echo Reading ASIC Dynamic EMI Adjust Threshold Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x0f)
			echo Reading ASIC 0x0f RESERVED Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x10)
			echo Reading ASIC 0x10 RESERVED Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x11)
			echo Reading ASIC 0x11 RESERVED Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x12)
			echo Reading ASIC PacketByte_0 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x13)
			echo Reading ASIC PacketByte_1 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x14)
			echo Reading ASIC PacketByte_2 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x15)
			echo Reading ASIC PacketByte_3 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x16)
			echo Reading ASIC PacketByte_4 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x17)
			echo Reading ASIC PacketByte_5 Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x18)
			echo Reading ASIC Port A GPIO Control Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x19)
			echo Reading ASIC Port A GPIO Data Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1a)
			echo Reading ASIC Port B GPIO Control and Data Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1b)
			echo Reading ASIC ERA Value Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1c)
			echo Reading ASIC ERA Address High Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1d)
			echo Reading ASIC ERA Address Low Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1e)
			echo Reading ASIC ERA Address Control Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end
		if ($asic_rd_addr == 0x1f)
			echo Reading ASIC Product ID Register \n
			#TODO: non-zero value? What does devBoard FW show?
			set $asic_rd_val = 0
		end

		
		# Remove all watchpoints
		delete


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 1 of Reg Read command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 1 (or could technically be response to previous command)
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 2 of Reg Read command \n
	
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 2
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 3 of Reg Read command \n
	
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 3
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 4 of Reg Read command \n
	
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		# Value "read" from ASIC register 
		set {int}0x40040008 = $asic_rd_val

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# SPI transaction complete
		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to change SPI MISO FIFO status after 4 response bytes for Reg Read command \n
	
		# Execute until watchpoint
		continue

		# Write SPI mark FIFO as empty so code stops reading it (and does not overflow...)
		set {int}0x4004000C = 0x00000003

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		echo \n
		echo HANDLED fnc0x0000491c(): Trackpad ASIC Reg Read. \n
		echo \n
	end
end


##
# This command handles simulatinng through Trackpad ASIC Extended Register 
#	Access Write with Auto Incrementation (i.e. writing to multiple 
#	sequentially addressed extended registers) fnc0x00004c14(). This 
#	consists of writing the ERA address registers (high and low) and then, 
#	for each write, writing the value, the ERA control, then reading the 
#	ERA control until it indicates the write is complete.
define check_trackpad_asic_era_write_autoinc
	# Check if we stopped at entry to Trackpad ASIC Extended Register Access (ERA) Write Auto Increment Function fnc0x0000491c()
	if $pc == 0x00004c14

		echo \n
		echo DETECTED fnc0x00004c14(): Trackpad ASIC ERA Write Auto Increment. \n
		echo \n

		# Keep track of how many ERAs to expect
		set $era_cnt = $r2

		# Write 0x1c (ERA Address High Byte):

		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 1 of Write command for ERA Address High Byte \n

		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 0
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove watchpoint
		delete 

		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 2 of Write command for ERA Address High Byte \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 1
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove watchpoint
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to change SPI MISO FIFO status after 2 response bytes for Reg Write command for ERA Address High Byte \n
		
		# Execute until watchpoint
		continue

		# Write SPI mark FIFO as empty so code stops reading it (and does not overflow...)
		set {int}0x4004000C = 0x00000003

		# Make sure we move past this instruction before next watch
		stepi

		# Remove watchpoint
		delete 


		# Write 0x1d (ERA Address Low Byte):

		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 1 of Write command for ERA Address Low Byte \n

		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 0
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove watchpoint
		delete 

		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 2 of Write command for ERA Address Low Byte \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 1
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove watchpoint
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to change SPI MISO FIFO status after 2 response bytes for Reg Write command for ERA Address Low Byte \n
		
		# Execute until watchpoint
		continue

		# Write SPI mark FIFO as empty so code stops reading it (and does not overflow...)
		set {int}0x4004000C = 0x00000003

		# Make sure we move past this instruction before next watch
		stepi

		# Remove watchpoint
		delete 


		# Loop over the specified number of consecutive accesses
		set $seq_cntr = 0

		while ($seq_cntr < $era_cnt)

			set $seq_cntr = $seq_cntr + 1

			# Write 0x1b (ERA Value):

			# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
			watch $pc == 0x00008f34

			echo Waiting to set SPI MISO response for Byte 1 of Write command for ERA Value \n

			# Execute until watchpoint
			continue

			# Write SPI response data and mark FIFO as not empty
			set {int}0x4004000C = 0x00000007
			#  Filler byte 0
			set {int}0x40040008 = 0x000000FB

			# Make sure we move past this instruction before next watch
			stepi

			# Remove watchpoint
			delete 

			# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
			watch $pc == 0x00008f34

			echo Waiting to set SPI MISO response for Byte 2 of Write command for ERA Value \n
			
			# Execute until watchpoint
			continue

			# Write SPI response data and mark FIFO as not empty
			set {int}0x4004000C = 0x00000007
			#  Filler byte 1
			set {int}0x40040008 = 0x000000FB

			# Make sure we move past this instruction before next watch
			stepi

			# Remove watchpoint
			delete 


			# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
			watch $pc == 0x00008f34

			echo Waiting to change SPI MISO FIFO status after 2 response bytes for Reg Write command for ERA Value \n
			
			# Execute until watchpoint
			continue

			# Write SPI mark FIFO as empty so code stops reading it (and does not overflow...)
			set {int}0x4004000C = 0x00000003

			# Make sure we move past this instruction before next watch
			stepi

			# Remove watchpoint
			delete 


			# Write 0x1e (ERA Control):

			# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
			watch $pc == 0x00008f34

			echo Waiting to set SPI MISO response for Byte 1 of Write command for ERA Control \n

			# Execute until watchpoint
			continue

			# Write SPI response data and mark FIFO as not empty
			set {int}0x4004000C = 0x00000007
			#  Filler byte 0
			set {int}0x40040008 = 0x000000FB

			# Make sure we move past this instruction before next watch
			stepi

			# Remove watchpoint
			delete 

			# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
			watch $pc == 0x00008f34

			echo Waiting to set SPI MISO response for Byte 2 of Write command for ERA Control \n
			
			# Execute until watchpoint
			continue

			# Write SPI response data and mark FIFO as not empty
			set {int}0x4004000C = 0x00000007
			#  Filler byte 1
			set {int}0x40040008 = 0x000000FB

			# Make sure we move past this instruction before next watch
			stepi

			# Remove watchpoint
			delete 


			# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
			watch $pc == 0x00008f34

			echo Waiting to change SPI MISO FIFO status after 2 response bytes for Reg Write command for ERA Control \n
			
			# Execute until watchpoint
			continue

			# Write SPI mark FIFO as empty so code stops reading it (and does not overflow...)
			set {int}0x4004000C = 0x00000003

			# Make sure we move past this instruction before next watch
			stepi

			# Remove watchpoint
			delete 


			# Read 0x1e (ERA Control)

			# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
			watch $pc == 0x00008f34

			echo Waiting to set SPI MISO response for Byte 1 of Reg Read command of ERA Control \n
			
			# Execute until watchpoint
			continue

			# Write SPI response data and mark FIFO as not empty
			set {int}0x4004000C = 0x00000007
			#  Filler byte 0
			set {int}0x40040008 = 0x000000FB

			# Make sure we move past this instruction before next watch
			stepi

			# Remove watchpoint
			delete 

			# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
			watch $pc == 0x00008f34

			echo Waiting to set SPI MISO response for Byte 2 of Reg Read command of ERA Control \n
			
			# Execute until watchpoint
			continue

			# Write SPI response data and mark FIFO as not empty
			set {int}0x4004000C = 0x00000007
			#  Filler byte 1
			set {int}0x40040008 = 0x000000FB

			# Make sure we move past this instruction before next watch
			stepi

			# Remove watchpoint
			delete 

			# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
			watch $pc == 0x00008f34

			echo Waiting to set SPI MISO response for Byte 3 of Reg Read command of ERA Control \n
			
			# Execute until watchpoint
			continue

			# Write SPI response data and mark FIFO as not empty
			set {int}0x4004000C = 0x00000007
			#  Filler byte 2
			set {int}0x40040008 = 0x000000FB

			# Make sure we move past this instruction before next watch
			stepi

			# Remove watchpoint
			delete 

			# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
			watch $pc == 0x00008f34

			echo Waiting to set SPI MISO response for Byte 4 of Reg Read command of ERA Control \n
			
			# Execute until watchpoint
			continue

			# Write SPI response data and mark FIFO as not empty
			set {int}0x4004000C = 0x00000007
			# Write that ERA Control returns 0x00 indicating extended register access is complete
			set {int}0x40040008 = 0x00000000

			# Make sure we move past this instruction before next watch
			stepi

			# Remove watchpoint
			delete 

			# SPI transaction complete
			# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
			watch $pc == 0x00008f34

			echo Waiting to change SPI MISO FIFO status after 4 response bytes for Reg Read command of ERA Control \n
			
			# Execute until watchpoint
			continue

			# Write SPI mark FIFO as empty so code stops reading it (and does not overflow...)
			set {int}0x4004000C = 0x00000003

			# Make sure we move past this instruction before next watch
			stepi

			# Remove watchpoint
			delete 

		end

		echo \n
		echo HANDLED fnc0x00004c14()): Trackpad ASIC ERA Write Auto Increment. \n
		echo \n
	end
end


##
# This command handles simulating through function that is expecting PINT3/4 to
#	fire fnc0x0000b97c(). These IRQs are related to Right and Left Trackpad
#	ASIC respectively. This may be related to calibrating the EMI settings 
#	for the Trackpad ASICs so that they trigger properly (i.e. on finger down, etc.)
define check_trackpad_asic_dr_interrupts
	# Check if we stopped at entry to fnc0x0000b97c(), which is waiting for
	#  either PINT3 or PINT4 to fire to get trackpad ASIC update data
	if $pc == 0x0000b97c

		echo \n
		echo DETECTED fnc0x0000b97c(): Trackpad ASIC Data Ready Interrupt. \n
		echo \n

		# Remove all watchpoints
		delete


		# Record which trackpad ASIC we are talking to
		set $trackpad_num = $r0

		if $trackpad_num == 0
			# Index to indicate which group of global data is stable
			#  to be read
			set {char}0x10000248 = 1 - *(char*)0x10000248
			# Flag to indicate ISR has fired desired number of times	
			set {char}0x1000024a = 1
		end
		if $trackpad_num == 1
			# Index to indicate which group of global data is stable
			#  to be read
			set {char}0x10000249 = 1 - *(char*)0x10000249
			# Flag to indicate ISR has fired desired number of times	
			set {char}0x1000024b = 1
		end


		echo \n
		echo HANDLED fnc0x0000b97c(): Trackpad ASIC Data Ready Interrupt. \n
		echo \n
	end
end


##
# This command handles when EEPROM data is being read
define eeprom_data_rd
	# Check if we are at entry point of a function which handles EEPROM read
	if $pc == 0x00000bdc ||  $pc == 0x000051c4
		echo \n
		echo DETECTED fnc0x00000bdc() or fnc0x000051c4: EEPROM Data Read. \n
		echo \n

		# Remove all watchpoints
		delete
		
		# Record and check input parameters
		set $eeprom_offset = $r0
		set $ram_wr_addr = $r1
		set $num_bytes = $r2

		# Continue until EEPROM data has been read
		watch $pc == 0x00000bf4
		watch $pc == 0x000051dc

		# Execute until watchpoint
		continue

		# Remove all watchpoints
		delete 

		# Data pulled from controller using command "eeprom read 8 0 0xF80"
		set $eeprom_data = {\
0x5A, 0xA5, 0x05, 0x00, 0x0A, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x50, 0x4D, 0x35, 0x34, \
0x37, 0x30, 0x32, 0x44, 0x41, 0x32, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x46, 0x43, 0x35, 0x35, \
0x31, 0x32, 0x33, 0x44, 0x31, 0x44, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x5D, 0x9C, \
0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x01, 0x0D, 0xFF, 0xFF, \
0x03, 0x09, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, \
0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0xAA, 0x55, 0x55, 0xAA, 0x1D, 0x00, 0x00, 0x00, \
0x2B, 0x00, 0x00, 0x00, 0xF4, 0xFF, 0xFF, 0xFF, \
0x0B, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, \
0x9E, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0xBA, 0xDC, 0xC7, 0xFD, 0x12, 0xCA, 0x35, 0x05, \
0x04, 0xE6, 0x74, 0xF3, 0xF3, 0xE6, 0x02, 0xF6, \
0x3E, 0xEF, 0x3A, 0x07, 0x28, 0xE3, 0xC1, 0x11, \
0x1E, 0x00, 0xE3, 0x01, 0x2E, 0x05, 0x38, 0x05, \
0x1D, 0x03, 0x25, 0x07, 0xA9, 0xFF, 0xBA, 0xDC, \
0xFB, 0xFF, 0x3E, 0xC5, 0x1B, 0x06, 0x7D, 0xE4, \
0xF2, 0xF3, 0x03, 0xE3, 0xD5, 0xF4, 0xFC, 0xEC, \
0xE7, 0x08, 0xA8, 0xE1, 0x92, 0x15, 0x0A, 0x00, \
0x48, 0x02, 0x84, 0x06, 0x54, 0x05, 0x48, 0x03, \
0x72, 0x07, 0xB3, 0xFF, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, \
0x62, 0x00, 0xDE, 0x00, 0x2A, 0x01, 0x58, 0x01, \
0x7A, 0x01, 0x96, 0x01, 0xDC, 0x01, 0xA0, 0x02, \
0xCE, 0x02, 0xF6, 0x02, 0x18, 0x03, 0x4C, 0x03, \
0x6E, 0x03, 0x05, 0x00, 0x05, 0x00, 0x5E, 0x00, \
0x17, 0x04, 0x88, 0x00, 0x7F, 0x00, 0x97, 0x04, \
0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, \
0x33, 0x00, 0x27, 0x05, 0x88, 0x00, 0x4F, 0x00, \
0x75, 0x05, 0xC7, 0x00, 0x54, 0x00, 0x75, 0x05, \
0x88, 0x00, 0x7B, 0x00, 0xE0, 0x06, 0x88, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x33, 0x00, \
0x20, 0x06, 0x88, 0x00, 0x4F, 0x00, 0xE0, 0x06, \
0xC7, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x80, 0x00, \
0x94, 0x02, 0x7D, 0x00, 0x80, 0x00, 0x94, 0x02, \
0x7D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, \
0x80, 0x00, 0x94, 0x02, 0x7D, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x7D, 0x00, 0x80, 0x00, 0x0B, 0x02, \
0x7D, 0x00, 0x80, 0x00, 0x94, 0x02, 0xFA, 0x00, \
0x80, 0x00, 0x10, 0x03, 0xFA, 0x00, 0x00, 0x00, \
0x00, 0x00, 0xFA, 0x00, 0x80, 0x00, 0x88, 0x01, \
0xFA, 0x00, 0x80, 0x00, 0x94, 0x02, 0x7D, 0x00, \
0x80, 0x00, 0x94, 0x02, 0x7D, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x7D, 0x00, 0x80, 0x00, 0x94, 0x02, \
0x7D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, \
0x80, 0x00, 0x0B, 0x02, 0x7D, 0x00, 0x80, 0x00, \
0x94, 0x02, 0xFA, 0x00, 0x80, 0x00, 0x10, 0x03, \
0xFA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFA, 0x00, \
0x80, 0x00, 0x88, 0x01, 0xFA, 0x00, 0x0A, 0x00, \
0x02, 0x00, 0x60, 0x00, 0xC0, 0x0D, 0x2F, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x7F, 0x00, \
0x17, 0x04, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x03, 0x00, 0x7D, 0x00, 0xC0, 0x0D, 0x2C, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x18, 0x00, 0x7B, 0x00, 0x17, 0x04, \
0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x00, \
0x75, 0x00, 0x17, 0x04, 0x3E, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x11, 0x01, 0x7F, 0x00, 0xC0, 0x0D, \
0x32, 0x00, 0x05, 0x00, 0x02, 0x00, 0x5C, 0x00, \
0xBA, 0x02, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, \
0x66, 0x00, 0xBA, 0x02, 0x88, 0x00, 0x76, 0x00, \
0x17, 0x04, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00, \
0x99, 0x01, 0x38, 0x00, 0x75, 0x05, 0x19, 0x01, \
0x02, 0x00, 0x03, 0x00, 0x40, 0x00, 0xBA, 0x02, \
0x99, 0x01, 0x56, 0x00, 0x17, 0x04, 0x44, 0x02, \
0x00, 0x00, 0x00, 0x00, 0x11, 0x01, 0x46, 0x00, \
0xA4, 0x03, 0x11, 0x01, 0x8E, 0x00, 0x75, 0x05, \
0xBB, 0x01, 0x02, 0x00, 0x02, 0x00, 0x40, 0x00, \
0x75, 0x05, 0x88, 0x00, 0xC8, 0x00, 0x2D, 0x08, \
0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, \
0x7A, 0x00, 0xE0, 0x06, 0xA5, 0x00, 0x06, 0x00, \
0x05, 0x00, 0x5E, 0x00, 0x17, 0x04, 0xAA, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x01, 0x00, 0x4B, 0x00, 0x70, 0x03, \
0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, \
0x7F, 0x00, 0x75, 0x05, 0x66, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x88, 0x00, 0x2E, 0x00, 0xBA, 0x02, \
0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x5E, 0x00, \
0x17, 0x04, 0x66, 0x00, 0x04, 0x00, 0x1C, 0x00, \
0x0E, 0x00, 0x5D, 0x01, 0x32, 0x03, 0x2A, 0x00, \
0x88, 0x01, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00, \
0x22, 0x00, 0x32, 0x00, 0x0B, 0x02, 0x32, 0x03, \
0x30, 0x00, 0xD2, 0x01, 0x5B, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x0B, 0x00, 0x36, 0x00, 0xB8, 0x01, \
0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, \
0x3E, 0x00, 0xD2, 0x01, 0x57, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x0F, 0x00, 0x38, 0x00, 0xB8, 0x01, \
0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, \
0x46, 0x00, 0xD2, 0x01, 0x44, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x11, 0x01, 0x58, 0x00, 0x4B, 0x02, \
0x66, 0x00, 0x4C, 0x00, 0x0B, 0x02, 0x84, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x52, 0x00, \
0x4B, 0x02, 0x66, 0x00, 0x48, 0x00, 0x0B, 0x02, \
0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, \
0x4E, 0x00, 0x4B, 0x02, 0x44, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x11, 0x01, 0x66, 0x00, 0xBA, 0x02, 0x66, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x82, 0x00, \
0x93, 0x02, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x03, 0x00, 0x7C, 0x00, 0xBA, 0x02, 0x66, 0x00, \
0x90, 0x00, 0x93, 0x02, 0x80, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x08, 0x00, 0xAA, 0x00, 0xBA, 0x02, 0x55, 0x01, \
0x07, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x75, 0x05, \
0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0x00, \
0x7F, 0x00, 0x97, 0x04, 0x3D, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x34, 0x00, 0x78, 0x00, 0x75, 0x05, \
0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, \
0x7F, 0x00, 0x97, 0x04, 0x46, 0x00, 0x03, 0x00, \
0x03, 0x00, 0x46, 0x00, 0x93, 0x02, 0x8B, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x5A, 0x00, \
0x93, 0x02, 0xAA, 0x00, 0x52, 0x00, 0xBA, 0x02, \
0x8B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, \
0x46, 0x00, 0xBA, 0x02, 0x9E, 0x00, 0x02, 0x00, \
0x03, 0x00, 0x47, 0x00, 0x75, 0x05, 0x11, 0x01, \
0x32, 0x00, 0x70, 0x03, 0x11, 0x01, 0x26, 0x00, \
0xE0, 0x06, 0x88, 0x00, 0x22, 0x00, 0x17, 0x04, \
0x11, 0x01, 0x33, 0x00, 0xBA, 0x02, 0x88, 0x00, \
0x05, 0x00, 0x03, 0x00, 0x5E, 0x00, 0x17, 0x04, \
0x88, 0x00, 0x7F, 0x00, 0xA4, 0x03, 0x88, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x33, 0x00, \
0x70, 0x03, 0x88, 0x00, 0x4F, 0x00, 0xBA, 0x02, \
0xC7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x01, \
0x54, 0x00, 0x75, 0x05, 0x88, 0x00, 0x7B, 0x00, \
0xE0, 0x06, 0xCD, 0x00, 0x05, 0x00, 0x00, 0x00, \
0x64, 0x00, 0x20, 0x06, 0xC8, 0x00, 0xC8, 0x00, \
0xC8, 0x05, 0xC8, 0x00, 0x64, 0x00, 0x27, 0x05, \
0xC8, 0x00, 0xC8, 0x00, 0x27, 0x05, 0xC8, 0x00, \
0x64, 0x00, 0xC8, 0x05, 0xD6, 0x00, 0x0B, 0x00, \
0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, \
0x56, 0x00, 0xDC, 0x03, 0xC6, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x04, 0x00, 0x5B, 0x00, 0xA4, 0x03, \
0xCE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x5B, 0x00, \
0x70, 0x03, 0xCE, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x03, 0x00, 0x3B, 0x00, 0x20, 0x06, 0xC1, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x61, 0x00, \
0x93, 0x02, 0xD7, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x06, 0x00, 0x39, 0x00, 0xB8, 0x07, 0xC5, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x32, 0x00, \
0x49, 0x07, 0xCE, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, \
0x3F, 0x00, 0xE0, 0x06, 0xC8, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x0A, 0x00, 0x5B, 0x00, 0x10, 0x03, \
0xBF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, \
0x35, 0x00, 0x27, 0x05, 0xD5, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }

		# Fill in RAM with values that should have been read from EEPROM
		set $idx = 0

		while ($idx < $num_bytes) 
			set {char}$ram_wr_addr = $eeprom_data[$eeprom_offset]
			set $idx = $idx + 1
			set $ram_wr_addr = $ram_wr_addr + 1
			set $eeprom_offset = $eeprom_offset + 1
		end

		echo \n
		echo HANDLED fnc0x00000bdc() or fnc0x000051c4: EEPROM Data Read. \n
		echo \n
	end
end


##
# This command handles simulating the PINT3 IRQ firing. 
#  PINT3 is triggerd on rising edge of PIO0_23, which is DR on the Right
#  Haptic.
define check_pint3_isr_sim
	if $pc == 0x000055e8

		# Remove all watchpoints
		delete

		# Check if PIO0_23 was setup
		if $r0 == 0 && $r1 == 23 

			echo \n
			echo DETECTED Entry point fnc0x000055e8(): Setup PINT3 (destructive) \n
			echo \n

			# Wait until exit of function
			watch $pc == 0x00005630

			# Execute until watchpoint
			continue

			# Remove all watchpoints
			delete

			echo \n
			echo Jumping to PINT3 Interrupt Handler \n
			echo \n

			# Jump to PINT3 Interrupt Handler
			set $lr = $pc
			set $pc = 0x00000138

			# This is enable for handling ISR data if set to 0 ISR just returns
			##set {char}0x10000242 = 0x0

			# Counter that is incremented each time ISR fires (if 0x10000242 == 1)
			# If count is 0xa on ISR entry then 0x1000024c is set to 1
			##set {char}0x10000246 = 0xa

			# Flag that is set after 0x10000246 counter reaches 0xb (i.e. ISR has
			#  fired 10 times.
			##set {char}0x1000024c = 0x1

			# If 0x1000024c flag is set, then ISR checks if 0x10000246 has counted
			#  up to 0x13
			##set {char}0x10000246 = 0x12

			# TODO: Other variable settings to consider (i.e. 0x1000024e??)

			# Set after Trackpad calibration routine
			set {char}0x1000024e = 0x2

			# Checked in PINT3 if 0x1000024e = 0x2
			#set {short}0x10000b70 = 0xfdc7

			echo \n
			echo HANDLED Entry point fnc0x000055e8(): Setup PINT3 (destructive) \n
			echo \n

		end
	end
end


##
# This command handles simulating the CT32B0 IRQ firing. 
#  	TODO: more details (i.e. related to haptics and jingle)
define check_ct32b0_isr_sim
	# Check if everything related to CT32B0 firing has been setup
	if $pc == 0x00007a38

		echo \n
		echo DETECTED Return from fnc0x00007a10(): CT32B0 Interrupt Simulation (destructive) \n
		echo \n

		# Remove all watchpoints
		delete

		echo \n
		echo Jumping to CT32B0 Interrupt Handler \n
		echo \n

		# Jump to CT32B0 Interrupt Handler
		set $lr = $pc
		set $pc = 0x000001b0

		# Indicate which MR has caused interrupt 
		# MR1 = right haptic
		set {int}0x40014000 = 0x2
		# MR2 = left haptic
		##set {int}0x40014000 = 0x4

##TODO: add special cases for handling clearing of interrupts?? (i.e. so ISR exits??)

		echo \n
		echo HANDLED Return from fnc0x00007a10(): CT32B0 Interrupt Simulation (destructive) \n
		echo \n
	end
end


## 
# This command handles function fnc0x0000573c(), which is optimized call for
#   reading values of Trackpad ASIC registers and clearing Trackpad ASIC Flags
define check_spi_asic_rd_reg_0x11_0x12
	if $pc == 0x0000573c

		echo \n
		echo DETECTED Entry point of fnc0x0000573c(): Read SPI ASIC Reg 0x11 and 0x12 \n
		echo \n

		# Remove all watchpoints
		delete


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 1 of Read SPI ASIC Reg 0x11 and 0x12 command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 1 (or could technically be response to previous command)
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 2 of Read SPI ASIC Reg 0x11 and 0x12 command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 2 
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 3 of Read SPI ASIC Reg 0x11 and 0x12 command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler byte 3 
		set {int}0x40040008 = 0x000000FB

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 4 of Read SPI ASIC Reg 0x11 and 0x12 command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Value of Trackpad ASIC Register 0x11
		set {int}0x40040008 = 0x00000000

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 5 of Read SPI ASIC Reg 0x11 and 0x12 command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Value of Trackpad ASIC Register 0x12
		set {int}0x40040008 = 0x00000000

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 6 of Read SPI ASIC Reg 0x11 and 0x12 command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler Byte 1 for Trackpad ASIC Flag Clear
		set {int}0x40040008 = 0x00000000

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to set SPI MISO response for Byte 7 of Read SPI ASIC Reg 0x11 and 0x12 command \n
		
		# Execute until watchpoint
		continue

		# Write SPI response data and mark FIFO as not empty
		set {int}0x4004000C = 0x00000007
		#  Filler Byte 2 for Trackpad ASIC Flag Clear
		set {int}0x40040008 = 0x00000000

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		# SPI transaction complete
		# Setup watchpoint for instruction setting mask to check SSP/SPI Status Register Receive FIFO Not Empty bit
		watch $pc == 0x00008f34

		echo Waiting to change SPI MISO FIFO status after 7 response bytes for Reg Read command \n
	
		# Execute until watchpoint
		continue

		# Write SPI mark FIFO as empty so code stops reading it (and does not overflow...)
		set {int}0x4004000C = 0x00000003

		# Make sure we move past this instruction before next watch
		stepi

		# Remove all watchpoints
		delete 


		echo \n
		echo HANDLED Entry point of fnc0x0000573c(): Read SPI ASIC Reg 0x11 and 0x12 \n
		echo \n
	end
end
