###############################################################################
# Old portions of command file for simulating Stream Controller firmware using 
#	pinkySim. This mainly contains setup for simulating IRQs (which is 
#	currently a destructive process). This is here in case we need to 
#	simulate IRQs again or refer to this setups and so that it does not
#	dirty up gdbCmdFile.
#
# Note this was developed by simulating vcf_wired_controller_d0g_57bf5c10.bin,
#  and may not work properly with other firmware.
#
#  MIT License
# 
#  Copyright (c) 2018 Gregory Gluszek
# 
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
# 
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
# 
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
###############################################################################

# TODO: Add details for simulating all IRQs and callbacks


# Related to main loop:
	#------------------------------------------------------------------------------#

	# This flag indicates that USB_Configure_Event has fired and will
 	#  cause main loop to call WriteEP() to send HID update messages
	set {char}0x10000344 = 1
	# Write EP is using this as a buffer... Not setup properly due to some
	#  IRQ/callback/bootROM code not running?
	set {int} 0x200040c0 = 0x20004700

	#------------------------------------------------------------------------------#


	# Setup watchpoint right after PMU:PCON write (and before wfi)
	# Note that going past this loops us back to 0x10000074 check and so on...
	watch $pc == 0x000043d0

	# Execute until watchpoint
	continue

	# Remove watchpoint
	delete 


	#------------------------------------------------------------------------------#


# USB_Configure_Event:
	##set $lr = $pc
	# arg0 = hUsb
	##set $r0 = 0x20004118
	# USB_Configure_Event
	##set $pc = 0x00004e58


# USB_Reset_Event:
	##set $lr = $pc
	# arg0 = hUsb
	##set $r0 = 0x20004118
	# USB_Reset_Event
	##set $pc = 0x00008d8a


# USB_Suspend_Event:
	##set $lr = $pc
	# arg0 = hUsb
	##set $r0 = 0x20004118
	# USB_Suspend_Event
	##set $pc = 0x0000995c


# USB_Resume_Event:
	##set $lr = $pc
	# arg0 = hUsb
	##set $r0 = 0x20004118
	# Simulate USB_Suspend_Event has executed
	##set {char}0x10000345 = 1
	##set {int}0x100010dc = 0x00009989
	##set {int}0x100010d8 = 0x00000001 
	# USB_Resume_Event
	##set $pc = 0x00008de4


# Interrupt_15_I2C:
	##
	# NOTE: We don't need to simulate I2C interrupt as we can abstract 
	#  communications at higher level since lpc_chip_11uxx_lib is being used
	#  for I2C comms. Leaving this here for history's sake.
	#
	# I2C: (IRQ15) An interrupt is generated by I2C controller when the I2C
	#  state changes.
	# NOTE: This is DESTRUCTIVE of processor state. Use only to obtain simulation of 
	#  interrupt. Vector Table entry is 0x00000199.
	##set $lr = $pc
	##set $pc = 0x00000198
	# Set I2C STAT code: A START condition has been transmitted.
	##set {int}0x40000004 = 0x08
	##


# Interrupt_16_CT16B0:
	##
	# CT16B0: An interrupt is generated when MR0 matches the value in the TC.
	# NOTE: This is DESTRUCTIVE of processor state. Use only to obtain simulation of 
	#  interrupt. Vector Table entry is 0x00000129.
	##set $lr = $pc
	##set $pc = 0x000001a0
	# Set Interrupt Register to indicate Interrupt flag for match channel 0
	##set {int}0x4000c000 = 1
	# TODO: Try adding watch for clearing IR once it's written? Or are we confident we have ISR mapped?
	#TODO: Might want to try making not destructive (if need to simulate it or other
	#  interrupts in the future). See Fig 81 in UM10462 for what to save to stack, 
	#  and update LR. Then when we get back to PC of wfi we manually pop off stack. 
	##


# Interrupt_24_ADC:
	##
	# ADC Interrupt Execution:
	# NOTE: This is DESTRUCTIVE of processor state. Use only to obtain simulation of 
	#  interrupt. Vector Table entry is 0x00000205.
	##set $lr = $pc
	##set $pc = 0x00000204
	# Counter for how many times interrupt fires initially before AD values
	#  start being accumulated
	set {int}0x10000014 = 0x0000012d
	# Counter for how many times interrupt fires for accumulating AD6 values
	set {int}0x10000018 = 0x00000007
	# Set flag to indicate ADC ISR has served its purpose and ADC is shutdown
	set {char}0x10000010 = 1
	# Set value of 8 accumulated channel 6 ADC values
	#  ADC Chanel 6 reads ~0x03ac when polled via adcRead command in custom firmware.
	set {short}0x10000f8c = 0x1d60
	#TODO: Might want to try making not destructive (if need to simulate it or other
	#  interrupts in the future). See Fig 81 in UM10462 for what to save to stack, 
	#  and update LR. Then when we get back to PC of wfi we manually pop off stack. 
	## 
