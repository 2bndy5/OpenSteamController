The goal of this document is to provide a quick reference such that when a call
 is made into Boot ROM we can tell what function is being called. This is all
 decomposed from the source provided in lpcopen_v2_03_lpcxpresso_nxp_lpcxpresso_11u37h.zip,
 a version of the LPCOpen Software Development Platform.


There are only two direct offsets into Boot ROM. Both can be found in lpc_chip_11uxx_lib/inc/chip.h:

#define IAP_ENTRY_LOCATION        0X1FFF1FF1                                    
#define LPC_ROM_API_BASE_LOC      0x1FFF1FF8



IAP_ENTRY_LOCATION is function call for IAP Commands as defined in lpc_chip_11uxx_lib/inc/romapi_11xx.h:

/**                                                                             
 * @brief LPC11XX IAP_ENTRY API function type                                   
 */                                                                             
typedef void (*IAP_ENTRY_T)(unsigned int[], unsigned int[]);                    
                                                                                
static INLINE void iap_entry(unsigned int cmd_param[], unsigned int status_result[])
{                                                                               
        ((IAP_ENTRY_T) IAP_ENTRY_LOCATION)(cmd_param, status_result);           
}

See 20.14 IAP commands of UM10462.pdf for detials. 



LPC_ROM_API_BASE_LOC is an address that holds a pointer to LPC_ROM_API_T as defined in lpc_chip_11uxx_lib/inc/chip.h:

#define LPC_ROM_API               (*((LPC_ROM_API_T        * *) LPC_ROM_API_BASE_LOC))

Reading 0x1fff1ff8 (LPC_ROM_API_BASE_LOC) gives us 0x1fff1eb8.

This means that if we read 0x1fff1eb8 we will be reading LPC_ROM_API_T as defined in lpc_chip_11uxx_lib/inc/romapi_11xx.h:

 /**                                                                             
  * @brief LPC11XX High level ROM API structure                                  
  */ 
 typedef struct {                                                                
         const uint32_t usbdApiBase;                             /*!< USBD API function table base address */
         const uint32_t reserved0;                               /*!< Reserved */
         const uint32_t candApiBase;                             /*!< CAN API function table base address */
         const uint32_t pwrApiBase;                              /*!< Power API function table base address */
         const uint32_t reserved1;                               /*!< Reserved */
         const uint32_t reserved2;                               /*!< Reserved */
         const uint32_t reserved3;                               /*!< Reserved */
         const uint32_t reserved4;                               /*!< Reserved */
 } LPC_ROM_API_T;


The first value we read from 0x1fff1eb8 is 0x1fff1f24, which is LPC_ROM_API->usbdApiBase.

LPC_ROM_API->usbdApiBase is defined as a pointer to USBD_API_T in nxp_lpcxpresso_11u37_usbd_rom_libusb/example/src/libusbdev.c:

g_pUsbApi = (const USBD_API_T *) LPC_ROM_API->usbdApiBase;


USBD_API_T is defined a series of pointers to struct containing function pointers in lpc_chip_11uxx_lib/inc/usbd/usbd_rom_api.h:

(Note that the values from reading 0x1fff1f24 have been added to the descriptions below)

 /** \brief Main USBD API functions structure.                                   
  *  \ingroup Group_USBD                                                         
  *                                                                              
  *  This structure contains pointer to various USB Device stack's sub-module    
  *  function tables. This structure is used as main entry point to access       
  *  various methods (grouped in sub-modules) exposed by ROM based USB device    
  *  stack.                                                                      
  *                                                                              
  */                                                                             
 typedef struct USBD_API                                                         
 {                                                                               
   0x1fff1f80
   const USBD_HW_API_T* hw; /**< Pointer to function table which exposes functions 		
                            which interact directly with USB device stack's core 
                            layer.*/                                             
   0x1fff1f50
   const USBD_CORE_API_T* core; /**< Pointer to function table which exposes functions 		
                            which interact directly with USB device controller   
                            hardware.*/                                          
   0x1fff1fdc
   const USBD_MSC_API_T* msc; /**< Pointer to function table which exposes functions 		
                            provided by MSC function driver module.              
                            */                                                   
   0x1fff1f70
   const USBD_DFU_API_T* dfu; /**< Pointer to function table which exposes functions 		
                            provided by DFU function driver module.              
                            */                                                   
   0x1fff1f78
   const USBD_HID_API_T* hid; /**< Pointer to function table which exposes functions 		
                            provided by HID function driver module.              
                            */                                                   
   0x1fff1f44
   const USBD_CDC_API_T* cdc; /**< Pointer to function table which exposes functions 		
                            provided by CDC-ACM function driver module.          
                            */                                                   
   0x00000000
   const uint32_t* reserved6; /**< Reserved for future function driver module.   
                            */                                                   
   0x01111101
   const uint32_t version; /**< Version identifier of USB ROM stack. The version is		
                           defined as 0x0CHDMhCC where each nibble represents version
                           number of the corresponding component.                
                           CC -  7:0  - 8bit core version number                 
                            h - 11:8  - 4bit hardware interface version number   
                            M - 15:12 - 4bit MSC class module version number     
                            D - 19:16 - 4bit DFU class module version number     
                            H - 23:20 - 4bit HID class module version number     
                            C - 27:24 - 4bit CDC class module version number     
                            H - 31:28 - 4bit reserved                            
                            */                                                   
                                                                                 
 } USBD_API_T; 


Now we will find the function pointer values for functions defined in the above mentioned function pointer tables


For USBD_HW_API_T we read 0x1fff1f80

USBD_HW_API_T is defined in lpc_chip_11uxx_lib/inc/usbd/usbd_hw.h:

/**                                                                             
 *  \brief Hardware API functions structure.                                    
 *  \ingroup USBD_HW                                                            
 *                                                                              
 *  This module exposes functions which interact directly with USB device controller hardware.
 *                                                                              
 */                                                                             
typedef struct USBD_HW_API                                                      
{                                                                               
  /** \fn uint32_t GetMemSize(USBD_API_INIT_PARAM_T* param)                     
   *  Function to determine the memory required by the USB device stack's DCD and core layers.
   *                                                                            
   *  This function is called by application layer before calling pUsbApi->hw->Init(), to allocate memory used
   *  by DCD and core layers. The application should allocate the memory which is accessible by USB
   *  controller/DMA controller.                                                
   *  \note Some memory areas are not accessible by all bus masters.            
   *                                                                            
   *  \param[in] param Structure containing USB device stack initialization parameters.
   *  \return Returns the required memory size in bytes.                        
   */                                                                           
  0x1fff2e7f
  uint32_t (*GetMemSize)(USBD_API_INIT_PARAM_T* param); 

  /** \fn ErrorCode_t Init(USBD_HANDLE_T* phUsb, USB_CORE_DESCS_T* pDesc, USBD_API_INIT_PARAM_T* param)
   *  Function to initialize USB device stack's DCD and core layers.            
   *                                                                            
   *  This function is called by application layer to initialize USB hardware and core layers. 
   *  On successful initialization the function returns a handle to USB device stack which should
   *  be passed to the rest of the functions.                                   
   *                                                                            
   *  \param[in,out] phUsb Pointer to the USB device stack handle of type USBD_HANDLE_T. 
   *  \param[in]  pDesc Structure containing pointers to various descriptor arrays needed by the stack.
   *                    These descriptors are reported to USB host as part of enumerations process.
   *  \param[in]  param Structure containing USB device stack initialization parameters.
   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
   *          \retval LPC_OK(0) On success                                      
   *          \retval ERR_USBD_BAD_MEM_BUF(0x0004000b) When insufficient memory buffer is passed or memory
   *                                             is not aligned on 2048 boundary.
   */                                                                           
  0x1fff351d
  ErrorCode_t (*Init)(USBD_HANDLE_T* phUsb, USB_CORE_DESCS_T* pDesc, USBD_API_INIT_PARAM_T* param);
                                                                                
  /** \fn void Connect(USBD_HANDLE_T hUsb, uint32_t con)                        
   *  Function to make USB device visible/invisible on the USB bus.             
   *                                                                            
   *  This function is called after the USB initialization. This function uses the soft connect
   *  feature to make the device visible on the USB bus. This function is called only after the
   *  application is ready to handle the USB data. The enumeration process is started by the
   *  host after the device detection. The driver handles the enumeration process according to
   *  the USB descriptors passed in the USB initialization function.            
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] con  States whether to connect (1) or to disconnect (0).       
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff2e93
  void (*Connect)(USBD_HANDLE_T hUsb, uint32_t con);                            
                                                                                
  /** \fn void ISR(USBD_HANDLE_T hUsb)                                          
   *  Function to USB device controller interrupt events.                       
   *                                                                            
   *  When the user application is active the interrupt handlers are mapped in the user flash
   *  space. The user application must provide an interrupt handler for the USB interrupt and
   *  call this function in the interrupt handler routine. The driver interrupt handler takes
   *  appropriate action according to the data received on the USB bus.         
   *                                                                            
   *  \param[in]  hUsb Handle to the USB device stack.                          
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff3655
  void (*ISR)(USBD_HANDLE_T hUsb);

  /** \fn void Reset(USBD_HANDLE_T hUsb)                                        
   *  Function to Reset USB device stack and hardware controller.               
   *                                                                            
   *  Reset USB device stack and hardware controller. Disables all endpoints except EP0.
   *  Clears all pending interrupts and resets endpoint transfer queues.        
   *  This function is called internally by pUsbApi->hw->init() and from reset event.
   *                                                                            
   *  \param[in]  hUsb Handle to the USB device stack.                          
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff3449
  void  (*Reset)(USBD_HANDLE_T hUsb);                                           
                                                                                
  /** \fn void ForceFullSpeed(USBD_HANDLE_T hUsb, uint32_t cfg)                 
   *  Function to force high speed USB device to operate in full speed mode.    
   *                                                                            
   *  This function is useful for testing the behavior of current device when connected
   *  to a full speed only hosts.                                               
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] cfg  When 1 - set force full-speed or                          
   *                       0 - clear force full-speed.                          
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff2e7d
  void  (*ForceFullSpeed )(USBD_HANDLE_T hUsb, uint32_t cfg);                   
                                                                                
  /** \fn void WakeUpCfg(USBD_HANDLE_T hUsb, uint32_t cfg)                      
   *  Function to configure USB device controller to wake-up host on remote events.
   *                                                                            
   *  This function is called by application layer to configure the USB device controller 
   *  to wakeup on remote events. It is recommended to call this function from users's 
   *  USB_WakeUpCfg() callback routine registered with stack.                   
   *  \note User's USB_WakeUpCfg() is registered with stack by setting the USB_WakeUpCfg member 
   *  of USBD_API_INIT_PARAM_T structure before calling pUsbApi->hw->Init() routine.
   *  Certain USB device controllers needed to keep some clocks always on to generate 
   *  resume signaling through pUsbApi->hw->WakeUp(). This hook is provided to support 
   *  such controllers. In most controllers cases this is an empty routine.     
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] cfg  When 1 - Configure controller to wake on remote events or 
   *                       0 - Configure controller not to wake on remote events.
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff2ecb
  void  (*WakeUpCfg)(USBD_HANDLE_T hUsb, uint32_t  cfg); 

  /** \fn void SetAddress(USBD_HANDLE_T hUsb, uint32_t adr)                     
   *  Function to set USB address assigned by host in device controller hardware.
   *                                                                            
   *  This function is called automatically when USB_REQUEST_SET_ADDRESS request is received  
   *  by the stack from USB host.                                               
   *  This interface is provided to users to invoke this function in other scenarios which are not 
   *  handle by current stack. In most user applications this function is not called directly.
   *  Also this function can be used by users who are selectively modifying the USB device stack's 
   *  standard handlers through callback interface exposed by the stack.        
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] adr  USB bus Address to which the device controller should respond. Usually 
   *                  assigned by the USB host.                                 
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff2ee7
  void  (*SetAddress)(USBD_HANDLE_T hUsb, uint32_t adr);                        
                                                                                
  /** \fn void Configure(USBD_HANDLE_T hUsb, uint32_t cfg)                      
   *  Function to configure device controller hardware with selected configuration.
   *                                                                            
   *  This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received  
   *  by the stack from USB host.                                               
   *  This interface is provided to users to invoke this function in other scenarios which are not 
   *  handle by current stack. In most user applications this function is not called directly.
   *  Also this function can be used by users who are selectively modifying the USB device stack's 
   *  standard handlers through callback interface exposed by the stack.        
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] cfg  Configuration index.                                      
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff2f09
  void  (*Configure)(USBD_HANDLE_T hUsb, uint32_t  cfg);

  /** \fn void ConfigEP(USBD_HANDLE_T hUsb, USB_ENDPOINT_DESCRIPTOR *pEPD)      
   *  Function to configure USB Endpoint according to descriptor.               
   *                                                                            
   *  This function is called automatically when USB_REQUEST_SET_CONFIGURATION request is received  
   *  by the stack from USB host. All the endpoints associated with the selected configuration
   *  are configured.                                                           
   *  This interface is provided to users to invoke this function in other scenarios which are not 
   *  handle by current stack. In most user applications this function is not called directly.
   *  Also this function can be used by users who are selectively modifying the USB device stack's 
   *  standard handlers through callback interface exposed by the stack.        
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] pEPD Endpoint descriptor structure defined in USB 2.0 specification.
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff2f1f
  void  (*ConfigEP)(USBD_HANDLE_T hUsb, USB_ENDPOINT_DESCRIPTOR *pEPD);         
                                                                                
  /** \fn void DirCtrlEP(USBD_HANDLE_T hUsb, uint32_t dir)                      
   *  Function to set direction for USB control endpoint EP0.                   
   *                                                                            
   *  This function is called automatically by the stack on need basis.         
   *  This interface is provided to users to invoke this function in other scenarios which are not 
   *  handle by current stack. In most user applications this function is not called directly.
   *  Also this function can be used by users who are selectively modifying the USB device stack's 
   *  standard handlers through callback interface exposed by the stack.        
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] cfg  When 1 - Set EP0 in IN transfer mode                      
   *                       0 - Set EP0 in OUT transfer mode                     
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff2fa9
  void  (*DirCtrlEP)(USBD_HANDLE_T hUsb, uint32_t dir);                         
                                                                                
  /** \fn void EnableEP(USBD_HANDLE_T hUsb, uint32_t EPNum)                     
   *  Function to enable selected USB endpoint.                                 
   *                                                                            
   *  This function enables interrupts on selected endpoint.                    
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] EPNum  Endpoint number as per USB specification.               
   *                    ie. An EP1_IN is represented by 0x81 number.            
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff2fab
  void  (*EnableEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);

  /** \fn void DisableEP(USBD_HANDLE_T hUsb, uint32_t EPNum)                    
   *  Function to disable selected USB endpoint.                                
   *                                                                            
   *  This function disables interrupts on selected endpoint.                   
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] EPNum  Endpoint number as per USB specification.               
   *                    ie. An EP1_IN is represented by 0x81 number.            
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff2feb
  void  (*DisableEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);                       
                                                                                
  /** \fn void ResetEP(USBD_HANDLE_T hUsb, uint32_t EPNum)                      
   *  Function to reset selected USB endpoint.                                  
   *                                                                            
   *  This function flushes the endpoint buffers and resets data toggle logic.  
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] EPNum  Endpoint number as per USB specification.               
   *                    ie. An EP1_IN is represented by 0x81 number.            
   *  \return Nothing.                                                          
  */                                                                            
  0x1fff3019
  void  (*ResetEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);                         
                                                                                
  /** \fn void SetStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum)                   
   *  Function to STALL selected USB endpoint.                                  
   *                                                                            
   *  Generates STALL signaling for requested endpoint.                         
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] EPNum  Endpoint number as per USB specification.               
   *                    ie. An EP1_IN is represented by 0x81 number.            
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff305f
  void  (*SetStallEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);

  /** \fn void ClrStallEP(USBD_HANDLE_T hUsb, uint32_t EPNum)                   
   *  Function to clear STALL state for the requested endpoint.                 
   *                                                                            
   *  This function clears STALL state for the requested endpoint.              
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] EPNum  Endpoint number as per USB specification.               
   *                    ie. An EP1_IN is represented by 0x81 number.            
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff30c1
  void  (*ClrStallEP)(USBD_HANDLE_T hUsb, uint32_t EPNum);                      
                                                                                
  /** \fn ErrorCode_t SetTestMode(USBD_HANDLE_T hUsb, uint8_t mode)             
   *  Function to set high speed USB device controller in requested test mode.  
   *                                                                            
   *  USB-IF requires the high speed device to be put in various test modes     
   *  for electrical testing. This USB device stack calls this function whenever
   *  it receives USB_REQUEST_CLEAR_FEATURE request for USB_FEATURE_TEST_MODE.  
   *  Users can put the device in test mode by directly calling this function.  
   *  Returns ERR_USBD_INVALID_REQ when device controller is full-speed only.   
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] mode  Test mode defined in USB 2.0 electrical testing specification.
   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
   *          \retval LPC_OK(0) - On success                                    
   *          \retval ERR_USBD_INVALID_REQ(0x00040001) - Invalid test mode or   
   *                                             Device controller is full-speed only.
   */                                                                           
  0x1fff2f05
  ErrorCode_t (*SetTestMode)(USBD_HANDLE_T hUsb, uint8_t mode);   

  /** \fn uint32_t ReadEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData)   
   *  Function to read data received on the requested endpoint.                 
   *                                                                            
   *  This function is called by USB stack and the application layer to read the data
   *  received on the requested endpoint.                                       
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] EPNum  Endpoint number as per USB specification.               
   *                    ie. An EP1_IN is represented by 0x81 number.            
   *  \param[in,out] pData Pointer to the data buffer where data is to be copied. 
   *  \return Returns the number of bytes copied to the buffer.                 
   */                                                                           
  0x1fff3277
  uint32_t (*ReadEP)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData);       
                                                                                
  /** \fn uint32_t ReadReqEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t len)
   *  Function to queue read request on the specified endpoint.                 
   *                                                                            
   *  This function is called by USB stack and the application layer to queue a read request
   *  on the specified endpoint.                                                
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] EPNum  Endpoint number as per USB specification.               
   *                    ie. An EP1_IN is represented by 0x81 number.            
   *  \param[in,out] pData Pointer to the data buffer where data is to be copied. This buffer
   *                       address should be accessible by USB DMA master.      
   *  \param[in] len  Length of the buffer passed.                              
   *  \return Returns the length of the requested buffer.                       
   */                                                                           
  0x1fff3273
  uint32_t (*ReadReqEP)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t len);

  /** \fn uint32_t ReadSetupPkt(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t *pData)
   *  Function to read setup packet data received on the requested endpoint.    
   *                                                                            
   *  This function is called by USB stack and the application layer to read setup packet data
   *  received on the requested endpoint.                                       
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] EPNum  Endpoint number as per USB specification.               
   *                    ie. An EP0_IN is represented by 0x80 number.            
   *  \param[in,out] pData Pointer to the data buffer where data is to be copied. 
   *  \return Returns the number of bytes copied to the buffer.                 
   */                                                                           
  0x1fff321b
  uint32_t (*ReadSetupPkt)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t *pData);
                                                                                
  /** \fn uint32_t WriteEP(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t cnt)
   *  Function to write data to be sent on the requested endpoint.              
   *                                                                            
   *  This function is called by USB stack and the application layer to send data
   *  on the requested endpoint.                                                
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] EPNum  Endpoint number as per USB specification.               
   *                    ie. An EP1_IN is represented by 0x81 number.            
   *  \param[in] pData Pointer to the data buffer from where data is to be copied. 
   *  \param[in] cnt  Number of bytes to write.                                 
   *  \return Returns the number of bytes written.                              
   */                                                                           
  0x1fff3387
  uint32_t (*WriteEP)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint8_t *pData, uint32_t cnt);

  /** \fn void WakeUp(USBD_HANDLE_T hUsb)                                       
   *  Function to generate resume signaling on bus for remote host wakeup.      
   *                                                                            
   *  This function is called by application layer to remotely wakeup host controller 
   *  when system is in suspend state. Application should indicate this remote wakeup
   *  capability by setting USB_CONFIG_REMOTE_WAKEUP in bmAttributes of Configuration 
   *  Descriptor. Also this routine will generate resume signalling only if host
   *  enables USB_FEATURE_REMOTE_WAKEUP by sending SET_FEATURE request before suspending
   *  the bus.                                                                  
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff2eaf
  void  (*WakeUp)(USBD_HANDLE_T hUsb);                                          
                                                                                
  /** \fn void EnableEvent(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t event_type, uint32_t enable)
   *  Function to enable/disable selected USB event.                            
   *                                                                            
   *  This function enables interrupts on selected endpoint.                    
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in] EPNum  Endpoint number corresponding to the event.             
   *                    ie. An EP1_IN is represented by 0x81 number. For device events 
   *                    set this param to 0x0.                                  
   *  \param[in] event_type  Type of endpoint event. See \ref USBD_EVENT_T for more details.
   *  \param[in] enable  1 - enable event, 0 - disable event.                   
   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
   *          \retval LPC_OK(0) - On success                                    
   *          \retval ERR_USBD_INVALID_REQ(0x00040001) - Invalid event type.    
   */                                                                           
  0x1fff315f
  ErrorCode_t  (*EnableEvent)(USBD_HANDLE_T hUsb, uint32_t EPNum, uint32_t event_type, uint32_t enable);
                                                                                
} USBD_HW_API_T;



For USBD_CORE_API_T we read 0x1fff1f50

USBD_CORE_API_T is defined in lpc_chip_11uxx_lib/inc/usbd/usbd_core.h:

/** \brief USBD stack Core API functions structure.                             
 *  \ingroup USBD_Core                                                          
 *                                                                              
 *  \details  This module exposes functions which interact directly with USB device stack's core layer.
 *  The application layer uses this component when it has to implement custom class function driver or 
 *  standard class function driver which is not part of the current USB device stack.
 *  The functions exposed by this interface are to register class specific EP0 handlers and corresponding
 *  utility functions to manipulate EP0 state machine of the stack. This interface also exposes
 *  function to register custom endpoint interrupt handler.                     
 *                                                                              
 */
typedef struct USBD_CORE_API                                                    
{                                                                               
 /** \fn ErrorCode_t RegisterClassHandler(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, void* data)
  *  Function to register class specific EP0 event handler with USB device stack.
  *                                                                             
  *  The application layer uses this function when it has to register the custom class's EP0 handler. 
  *  The stack calls all the registered class handlers on any EP0 event before going through default 
  *  handling of the event. This gives the class handlers to implement class specific request handlers
  *  and also to override the default stack handling for a particular event targeted to the interface.
  *  Check \ref USB_EP_HANDLER_T for more details on how the callback function should be implemented. Also
  *  application layer could use this function to register EP0 handler which responds to vendor specific 
  *  requests.                                                                  
  *                                                                             
  *  \param[in] hUsb Handle to the USB device stack.                            
  *  \param[in] pfn  Class specific EP0 handler function.                       
  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
  *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
  *          \retval LPC_OK On success                                          
  *          \retval ERR_USBD_TOO_MANY_CLASS_HDLR(0x0004000c)  The number of class handlers registered is 
                        greater than the number of handlers allowed by the stack.
  *                                                                             
  */                                                                            
  0x1fff2ab7
  ErrorCode_t (*RegisterClassHandler)(USBD_HANDLE_T hUsb, USB_EP_HANDLER_T pfn, void* data);
                                                                                
 /** \fn ErrorCode_t RegisterEpHandler(USBD_HANDLE_T hUsb, uint32_t ep_index, USB_EP_HANDLER_T pfn, void* data)
  *  Function to register interrupt/event handler for the requested endpoint with USB device stack.
  *                                                                             
  *  The application layer uses this function to register the endpoint event handler. 
  *  The stack calls all the registered endpoint handlers when                  
  *  - USB_EVT_OUT or USB_EVT_OUT_NAK events happen for OUT endpoint.           
  *  - USB_EVT_IN or USB_EVT_IN_NAK events happen for IN endpoint.              
  *  Check USB_EP_HANDLER_T for more details on how the callback function should be implemented.
  *  \note By default endpoint _NAK events are not enabled. Application should call \ref USBD_HW_API_T::EnableEvent
  *  for the corresponding endpoint.                                            
  *                                                                             
  *  \param[in] hUsb Handle to the USB device stack.                            
  *  \param[in] ep_index  Endpoint index. Computed as                           
  *                       - For OUT endpoints = 2 * endpoint number eg. for EP2_OUT it is 4.
  *                       - For IN endopoints = (2 * endpoint number) + 1 eg. for EP2_IN it is 5.
  *  \param[in] pfn  Endpoint event handler function.                           
  *  \param[in] data Pointer to the data which will be passed when callback function is called by the stack. 
  *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
  *          \retval LPC_OK On success                                          
  *          \retval ERR_API_INVALID_PARAM2  ep_index is outside the boundary ( < 2 * USBD_API_INIT_PARAM_T::max_num_ep). 
  *                                                                             
  */                                                                            
  0x1fff29d7
  ErrorCode_t (*RegisterEpHandler)(USBD_HANDLE_T hUsb, uint32_t ep_index, USB_EP_HANDLER_T pfn, void* data);

  /** \fn void SetupStage(USBD_HANDLE_T hUsb)                                   
   *  Function to set EP0 state machine in setup state.                         
   *                                                                            
   *  This function is called by USB stack and the application layer to         
   *  set the EP0 state machine in setup state. This function will read         
   *  the setup packet received from USB host into stack's buffer.              
   *  \n                                                                        
   *  \note This interface is provided to users to invoke this function in other 
   *  scenarios which are not handle by current stack. In most user applications 
   *  this function is not called directly.Also this function can be used by    
   *  users who are selectively modifying the USB device stack's standard handlers 
   *  through callback interface exposed by the stack.                          
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff222f
  void (*SetupStage )(USBD_HANDLE_T hUsb);                                      
                                                                                
  /** \fn void DataInStage(USBD_HANDLE_T hUsb)                                  
   *  Function to set EP0 state machine in data_in state.                       
   *                                                                            
   *  This function is called by USB stack and the application layer to         
   *  set the EP0 state machine in data_in state. This function will write      
   *  the data present in EP0Data buffer to EP0 FIFO for transmission to host.  
   *  \n                                                                        
   *  \note This interface is provided to users to invoke this function in other 
   *  scenarios which are not handle by current stack. In most user applications 
   *  this function is not called directly.Also this function can be used by    
   *  users who are selectively modifying the USB device stack's standard handlers 
   *  through callback interface exposed by the stack.                          
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \return Nothing.                                                          
   */                                  
  0x1fff223f
  void (*DataInStage)(USBD_HANDLE_T hUsb);                                      
                                                                                
  /** \fn void DataOutStage(USBD_HANDLE_T hUsb)                                 
   *  Function to set EP0 state machine in data_out state.                      
   *                                                                            
   *  This function is called by USB stack and the application layer to         
   *  set the EP0 state machine in data_out state. This function will read      
   *  the control data (EP0 out packets) received from USB host into EP0Data buffer. 
   *  \n                                                                        
   *  \note This interface is provided to users to invoke this function in other 
   *  scenarios which are not handle by current stack. In most user applications 
   *  this function is not called directly.Also this function can be used by    
   *  users who are selectively modifying the USB device stack's standard handlers 
   *  through callback interface exposed by the stack.                          
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff226b
  void (*DataOutStage)(USBD_HANDLE_T hUsb);                                     
                                                                                
  /** \fn void StatusInStage(USBD_HANDLE_T hUsb)                                
   *  Function to set EP0 state machine in status_in state.                     
   *                                                                            
   *  This function is called by USB stack and the application layer to         
   *  set the EP0 state machine in status_in state. This function will send     
   *  zero length IN packet on EP0 to host, indicating positive status.         
   *  \n                                                                        
   *  \note This interface is provided to users to invoke this function in other 
   *  scenarios which are not handle by current stack. In most user applications 
   *  this function is not called directly.Also this function can be used by    
   *  users who are selectively modifying the USB device stack's standard handlers 
   *  through callback interface exposed by the stack.                          
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \return Nothing.                                                          
   */                                            
  0x1fff228d
  void (*StatusInStage)(USBD_HANDLE_T hUsb);                                    

  /** \fn void StatusOutStage(USBD_HANDLE_T hUsb)                               
   *  Function to set EP0 state machine in status_out state.                    
   *                                                                            
   *  This function is called by USB stack and the application layer to         
   *  set the EP0 state machine in status_out state. This function will read    
   *  the zero length OUT packet received from USB host on EP0.                 
   *  \n                                                                        
   *  \note This interface is provided to users to invoke this function in other 
   *  scenarios which are not handle by current stack. In most user applications 
   *  this function is not called directly.Also this function can be used by    
   *  users who are selectively modifying the USB device stack's standard handlers 
   *  through callback interface exposed by the stack.                          
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff2298
  void (*StatusOutStage)(USBD_HANDLE_T hUsb);                                   
                                                                                
  /** \fn void StallEp0(USBD_HANDLE_T hUsb)                                     
   *  Function to set EP0 state machine in stall state.                         
   *                                                                            
   *  This function is called by USB stack and the application layer to         
   *  generate STALL signaling on EP0 endpoint. This function will also         
   *  reset the EP0Data buffer.                                                 
   *  \n                                                                        
   *  \note This interface is provided to users to invoke this function in other 
   *  scenarios which are not handle by current stack. In most user applications 
   *  this function is not called directly.Also this function can be used by    
   *  users who are selectively modifying the USB device stack's standard handlers 
   *  through callback interface exposed by the stack.                          
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \return Nothing.                                                          
   */                                                                           
  0x1fff21b9
  void (*StallEp0)(USBD_HANDLE_T hUsb);                                         
                                                                                
} USBD_CORE_API_T;



For USBD_MSC_API_T we read 0x1fff1fdc

USBD_MSC_API_T is defined in lpc_chip_11uxx_lib/inc/usbd/usbd_mscuser.h:

/** \brief MSC class API functions structure.                                   
 *  \ingroup USBD_MSC                                                           
 *                                                                              
 *  This module exposes functions which interact directly with USB device controller hardware.
 *                                                                              
 */                                                                             
typedef struct USBD_MSC_API                                                     
{                                                                               
  /** \fn uint32_t GetMemSize(USBD_MSC_INIT_PARAM_T* param)                     
   *  Function to determine the memory required by the MSC function driver module.
   *                                                                            
   *  This function is called by application layer before calling pUsbApi->msc->Init(), to allocate memory used 
   *  by MSC function driver module. The application should allocate the memory which is accessible by USB
   *  controller/DMA controller.                                                
   *  \note Some memory areas are not accessible by all bus masters.            
   *                                                                            
   *  \param[in] param Structure containing MSC function driver module initialization parameters.
   *  \return Returns the required memory size in bytes.                        
   */                                                                           
  0x1fff145d
  uint32_t (*GetMemSize)(USBD_MSC_INIT_PARAM_T* param);                         
                                                                                
  /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_MSC_INIT_PARAM_T* param)    
   *  Function to initialize MSC function driver module.                        
   *                                                                            
   *  This function is called by application layer to initialize MSC function driver module.
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in, out] param Structure containing MSC function driver module initialization parameters.
   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
   *          \retval LPC_OK On success                                         
   *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte  
   *              aligned or smaller than required.                             
   *          \retval ERR_API_INVALID_PARAM2 Either MSC_Write() or MSC_Read() or
   *              MSC_Verify() callbacks are not defined.                       
   *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
   *          \retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed. 
   */                                                                           
  0x1fff1461
  ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_MSC_INIT_PARAM_T* param);        
                                                                                
} USBD_MSC_API_T;



For USBD_DFU_API_T we read 0x1fff1f70

USBD_DFU_API_T is defined in lpc_chip_11uxx_lib/inc/usbd/usbd_dfuuser.h:

/** \brief DFU class API functions structure.                                   
 *  \ingroup USBD_DFU                                                           
 *                                                                              
 *  This module exposes functions which interact directly with USB device controller hardware.
 *                                                                              
 */                                                                             
typedef struct USBD_DFU_API                                                     
{                                                                               
  /** \fn uint32_t GetMemSize(USBD_DFU_INIT_PARAM_T* param)                     
   *  Function to determine the memory required by the DFU function driver module.
   *                                                                            
   *  This function is called by application layer before calling pUsbApi->dfu->Init(), to allocate memory used 
   *  by DFU function driver module. The application should allocate the memory which is accessible by USB
   *  controller/DMA controller.                                                
   *  \note Some memory areas are not accessible by all bus masters.            
   *                                                                            
   *  \param[in] param Structure containing DFU function driver module initialization parameters.
   *  \return Returns the required memory size in bytes.                        
   */                                                                           
  0x1fff3a21
  uint32_t (*GetMemSize)(USBD_DFU_INIT_PARAM_T* param);                         
                                                                                
  /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_DFU_INIT_PARAM_T* param)    
   *  Function to initialize DFU function driver module.                        
   *                                                                            
   *  This function is called by application layer to initialize DFU function driver module. 
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in, out] param Structure containing DFU function driver module initialization parameters.
   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
   *          \retval LPC_OK On success                                         
   *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte aligned or smaller than required. 
   *          \retval ERR_API_INVALID_PARAM2 Either DFU_Write() or DFU_Done() or DFU_Read() call-backs are not defined.
   *          \retval ERR_USBD_BAD_DESC                                         
   *            - USB_DFU_DESCRIPTOR_TYPE is not defined immediately after      
   *              interface descriptor.                                         
   *            - wTransferSize in descriptor doesn't match the value passed    
   *              in param->wTransferSize.                                      
   *            - DFU_Detach() is not defined while USB_DFU_WILL_DETACH is set  
   *              in DFU descriptor.                                            
   *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
   */                                                                           
  0x1fff3a2b
  ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_DFU_INIT_PARAM_T* param, uint32_t init_state);
                                                                                
} USBD_DFU_API_T;



For USBD_HID_API_T we read 0x1fff1f78

USBD_HID_API_T is defined in lpc_chip_11uxx_lib/inc/usbd/usbd_hiduser.h:

 /** \brief HID class API functions structure.                                   
  *  \ingroup USBD_HID                                                           
  *                                                                              
  *  This structure contains pointers to all the function exposed by HID function driver module.
  *                                                                              
  */                                                                             
 typedef struct USBD_HID_API                                                     
 {                                                                               
   /** \fn uint32_t GetMemSize(USBD_HID_INIT_PARAM_T* param)                     
    *  Function to determine the memory required by the HID function driver module.
    *                                                                            
    *  This function is called by application layer before calling pUsbApi->hid->Init(), to allocate memory used 
    *  by HID function driver module. The application should allocate the memory which is accessible by USB
    *  controller/DMA controller.                                                
    *  \note Some memory areas are not accessible by all bus masters.            
    *                                                                            
    *  \param[in] param Structure containing HID function driver module initialization parameters.
    *  \return Returns the required memory size in bytes.                        
    */                                                                           
   0x1fff2cf1
   uint32_t (*GetMemSize)(USBD_HID_INIT_PARAM_T* param);
                                                                                 
   /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_HID_INIT_PARAM_T* param)    
    *  Function to initialize HID function driver module.                        
    *                                                                            
    *  This function is called by application layer to initialize HID function driver  
    *  module. On successful initialization the function returns a handle to HID 
    *  function driver module in passed param structure.                         
    *                                                                            
    *  \param[in] hUsb Handle to the USB device stack.                           
    *  \param[in, out] param Structure containing HID function driver module     
    *      initialization parameters.                                            
    *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
    *          \retval LPC_OK On success                                         
    *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte  
    *              aligned or smaller than required.                             
    *          \retval ERR_API_INVALID_PARAM2 Either HID_GetReport() or HID_SetReport()
    *              callback are not defined.                                     
    *          \retval ERR_USBD_BAD_DESC  HID_HID_DESCRIPTOR_TYPE is not defined 
    *              immediately after interface descriptor.                       
    *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
    *          \retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed. 
    */                                                                           
   0x1fff2cfd
   ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_HID_INIT_PARAM_T* param);
                                                                                 
 } USBD_HID_API_T;



For USBD_CDC_API_T we read 0x1fff1f44

USBD_CDC_API_T is defined in lpc_chip_11uxx_lib/inc/usbd/usbd_cdcuser.h:

/** \brief CDC class API functions structure.                                   
 *  \ingroup USBD_CDC                                                           
 *                                                                              
 *  This module exposes functions which interact directly with USB device controller hardware.
 *                                                                              
 */                                                                             
typedef struct USBD_CDC_API                                                     
{                                                                               
  /** \fn uint32_t GetMemSize(USBD_CDC_INIT_PARAM_T* param)                     
   *  Function to determine the memory required by the CDC function driver module.
   *                                                                            
   *  This function is called by application layer before calling pUsbApi->CDC->Init(), to allocate memory used 
   *  by CDC function driver module. The application should allocate the memory which is accessible by USB
   *  controller/DMA controller.                                                
   *  \note Some memory areas are not accessible by all bus masters.            
   *                                                                            
   *  \param[in] param Structure containing CDC function driver module initialization parameters.
   *  \return Returns the required memory size in bytes.                        
   */                                                                           
  0x1fff3d93
  uint32_t (*GetMemSize)(USBD_CDC_INIT_PARAM_T* param);                         
                                                                                
  /** \fn ErrorCode_t init(USBD_HANDLE_T hUsb, USBD_CDC_INIT_PARAM_T* param)    
   *  Function to initialize CDC function driver module.                        
   *                                                                            
   *  This function is called by application layer to initialize CDC function driver module.
   *                                                                            
   *  \param[in] hUsb Handle to the USB device stack.                           
   *  \param[in, out] param Structure containing CDC function driver module initialization parameters.
   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
   *          \retval LPC_OK On success                                         
   *          \retval ERR_USBD_BAD_MEM_BUF  Memory buffer passed is not 4-byte  
   *              aligned or smaller than required.                             
   *          \retval ERR_API_INVALID_PARAM2 Either CDC_Write() or CDC_Read() or
   *              CDC_Verify() callbacks are not defined.                       
   *          \retval ERR_USBD_BAD_INTF_DESC  Wrong interface descriptor is passed. 
   *          \retval ERR_USBD_BAD_EP_DESC  Wrong endpoint descriptor is passed. 
   */                                                                           
  0x1fff3d97
  ErrorCode_t (*init)(USBD_HANDLE_T hUsb, USBD_CDC_INIT_PARAM_T* param, USBD_HANDLE_T* phCDC);

  /** \fn ErrorCode_t SendNotification(USBD_HANDLE_T hCdc, uint8_t bNotification, uint16_t data)
   *  Function to send CDC class notifications to host.                         
   *                                                                            
   *  This function is called by application layer to send CDC class notifications to host. 
   *  See usbcdc11.pdf, section 6.3, Table 67 for various notification types the CDC device can send.
   *  \note The current version of the driver only supports following notifications allowed by ACM subclass:
   *  CDC_NOTIFICATION_NETWORK_CONNECTION, CDC_RESPONSE_AVAILABLE, CDC_NOTIFICATION_SERIAL_STATE.
   *  \n                                                                        
   *  For all other notifications application should construct the notification buffer appropriately
   *  and call hw->USB_WriteEP() for interrupt endpoint associated with the interface.
   *                                                                            
   *  \param[in] hCdc Handle to CDC function driver.                            
   *  \param[in] bNotification Notification type allowed by ACM subclass. Should be CDC_NOTIFICATION_NETWORK_CONNECTION,
   *        CDC_RESPONSE_AVAILABLE or CDC_NOTIFICATION_SERIAL_STATE. For all other types ERR_API_INVALID_PARAM2
   *        is returned. See usbcdc11.pdf, section 3.6.2.1, table 5.            
   *  \param[in] data Data associated with notification.                        
   *        \n For CDC_NOTIFICATION_NETWORK_CONNECTION a non-zero data value is interpreted as connected state.
   *        \n For CDC_RESPONSE_AVAILABLE this parameter is ignored.            
   *        \n For CDC_NOTIFICATION_SERIAL_STATE the data should use bitmap values defined in usbcdc11.pdf, 
   *        section 6.3.5, Table 69.                                            
   *  \return Returns \ref ErrorCode_t type to indicate success or error condition.
   *          \retval LPC_OK On success                                         
   *          \retval ERR_API_INVALID_PARAM2  If unsupported notification type is passed. 
   *                                                                            
   */                                                                           
  0x1fff3ba9
  ErrorCode_t (*SendNotification)(USBD_HANDLE_T hCdc, uint8_t bNotification, uint16_t data);
                                                                                
} USBD_CDC_API_T;      



